---
output:
 html_document:
  theme: yeti
---

<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<style>

code{
  background-color:#f2f2f2;
  border-radius: 25px;
}
 
span.co{
  color:#000080;
  font-weight: bold;
}
 
img{
  display: block;
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 10px;
  padding-bottom: 10px;
}

p{
  text-align: left;
  font-size: 18px;
}

ul, ol{
  line-height: 27px;
  text-align: left;
  font-size: 18px;
  margin-left: 0px;
}
 
blockquote{
  font-size: 18px;
  border-left: 8px solid #292093;
  background-color: #e6ffff;
  padding-left: 16px;
  padding-right: 16px;
}
 
.row{
  margin: auto;
}
 
table {
  border-collapse: collapse;
}

table, td, th {
  border: 1px solid black;
  padding: 5px;
  text-align: center;
  vertical-align: middle;
}
 
 /* Create two equal columns that floats next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

.roundBorder {
  border-radius: 25px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlack {
  border-radius: 25px;
  border: 10px solid #D3D3D3;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlackEx {
  border-radius: 5px;
  border: 5px solid #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}

.roundBorderEx {
  border-radius: 3px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}


.tt {
    position: relative;
    display: inline-block;
    class: inline; 
    font-weight: bold;
    font-family: "Avenir";
    font-size: 18px;
    border-bottom: 1px black;
}

/* Tooltip text */
.tt .ttText {
    visibility: hidden;
    font-weight: normal;
    font-size: 18px;
    width: 200px;
    background-color: black;
    border: 1px solid black;
    color: white;
    text-align: left;
    padding: 5px;
    border-radius: 6px;
    position: absolute;
    z-index: 1;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tt:hover .ttText {
    visibility: visible;
}

</style>

<h1 style="text-align: center;">Introduction to data science in R, Lesson 3:<br/>For Loops and Functions</h1>
<br>
<!img style="float: left; margin: 0px 0px 15px 15px;" src="nzpLogo.jpg" width="150" />
<p style = "text-align: center; font-size: 14px;">Brian S. Evans, Ph.D.<br />
Migratory Bird Center<br/>
Smithsonian Conservation Biology Institute</p>
<hr>

<p>In this lesson we will explore <b><i>for loops</i></b> and <b>functions</b>. A <b><i>for loop</i></b> is a block of code that allows you to repeat an operation a set number of iterations. A function is a set of code that allows you to create or modify objects in a repeatable way. As data analysis often includes many repeated tasks,  <i>for loops</i> and user-defined functions can save considerable time, shorten R scripts, and make your scripts more legible. Understanding how they work is crucial to developing good coding practices.</p>

</p>

<hr>

<h2>Setup for the lesson:</h2>

<p>For this lesson, we will use three example data frames: Iris sepal and petal measurements collected by botanist Edgar Anderson in the 1920's, bird traits collected by Wilman et al. (2014), and bird point count observations from Washington, DC (Evans et al. 2016).</p>

<p>Open R Studio and run the following lines of code to load the data into R:</p>
<br>

```{r, eval=FALSE}
#=================================================================================*
# ---- set up ----
#=================================================================================*

# Load libraries

library(RCurl)

library(tidyverse)

# Note: If you have yet to install these library, please do so with: 
# install.packages('rCurl') ; install.packages('tidyverse')

# Provide the web addresses of the files (note: iris is preloaded example data):

habitsURL <- getURL('https://raw.githubusercontent.com/bsevansunc/workshop_languageOfR/master/birdHabits.csv')

countsURL <- getURL('https://raw.githubusercontent.com/bsevansunc/workshop_languageOfR/master/birdCounts.csv')

# Read in the data:

birdHabits <- tbl_df(read.csv(text = habitsURL))

birdCounts <- tbl_df(read.csv(text = countsURL))

```

<br>
<p>Take a moment to explore the data:</p>
<br>

```{r, eval=FALSE}
# Explore the data (birdHabits example):

head(birdHabits)

dim(birdHabits)

attributes(birdHabits)

str(birdHabits)

summary(birdHabits)

```

<br>
<p>Have a look at the built-in iris dataset as well:</p>
<br>

```{r, eval=FALSE}
# Explore the iris data:

head(iris)

dim(iris)

attributes(iris)

str(iris)

summary(iris)
```

<br>
<p>For the iris dataset, I think it's best to do some familiar cleaning steps:</p>
<br>

```{r, eval=FALSE}

# Clean up iris for analysis:

irisTbl <- tbl_df(iris)

names(irisTbl) <-
  c('sepalLength',
    'sepalWidth',
    'petalLength',
    'petalWidth',
    'species')
```

<hr>
<img src="rWorkshop/images/Iris_setosa.jpg" 
	title="Iris setosa"
	alt = "picture of the flower Iris setosa"
	border="0"
	style= "float: right; 
	      padding-right: 0px;
	      border-style: solid;
	      border-width: 10px;
	      border-color: white;
	      width: 30%;"/>
	      
<h2>**For loops**</h2>

<br>
<p><b>Why would you use <i>for loops</i></b>? Let's look at a common example. You have been asked to calculate the mean petal length of three Iris species: <i>Iris setosa</i>, <i>Iris versicolor</i>, and <i>Iris virginica</i>.  (coded as the factor levels `setosa`, `versicolor`, and `virginica` in the `species` field of the `irisTbl` data frame). Using the `mean` function and tools that we have addressed thus far, use the following to calculate the mean petal length for each species:</p>
<br>
```{r, eval=FALSE}
# Filter irisTbl to setosa:

irisTbl[irisTbl$species == 'setosa', ]

# Extract the petalLength field (column):

irisTbl[irisTbl$species == 'setosa', ]$petalLength

# Calculate the mean of petal lengths:

mean(irisTbl[irisTbl$species == 'setosa', ]$petalLength)

```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise One:</h3>
<br>
<p>Calculate the mean petal length of each of the Iris species</p>
<br>
</blockquote>
<br>

<p>The code you generated above is very repetitive -- the only change in each of the lines you should have created above was the name of the species. Writing code like this makes your scripts unnecessarily long and prone to user input error. <b><i>For loops</i></b> should be used whenever a chunk of code is repeated more than twice.</p>

<p>We'll return to the Iris example a bit later, but for now let's start with a very simple <i>for loop</i>.</p> 
<br>
<hr>

<p>Writing proper <i>for loops</i> requires following these three steps:</p>
<br>

<ol>
<li><b>Output</b>: Always define an object for storing output (e.g., an empty vector, matrix, or list)</li>
<li><b>Sequence</b>: The locations for which the loop will run</li>
<li><b>Body</b>: This is the instructions for what will occur during each iteration of the loop</li>
</ol>

<br>

<p>Let's use some example data. We'll construct a vector, `v`  using a set of five numbers. </p>
<br>

```{r, eval=FALSE}
v <- c(1,1,2,3,5)
v
```
<br>

<p>We would like to modify the values in vector `v` by adding one to each value. This might be written mathematically as:<br>

$$V_{new, i} = V_{i} + 1$$
</p>
<br>

<p>Recall that value `v[i]` is equal to the value at position <i>i</i> in vector `v`. Let's take a look at the value of `v` at position 3:</p>
<br>

```{r, eval=FALSE}

v[3]

i <- 3

v[i]

v[3] == v[i]
```
<br>


<p>If we want to calculate `v + 1` at position 3, we would write:</p>
<br>

```{r, eval=FALSE}
v[3] + 1
```

<hr>

<h3><i>For loop</i>, output:</h3>

<br>
<p><i>For loop</i> development begins by defining an object of a given length that your <i>for loop</i> will write to. This step is <b>very important</b> -- your <i>for loop</i> will run much, much slower if you do not do so!</p>

<br>
<p>Vector objects are defined as follows:</p>
<br>

```{r, eval=FALSE}
vNew <- vector('numeric', length = length(v))

str(vNew)
```

<br>
<p>The first argument of the `vector` function is the type of object you would like to create. The next argument sets the length of the created object to be the equivalent to that of `v`.</p>
<br>

<p>Values of vector `vNew` will be replaced location-by-location. For example, let's compare the initial value of `v` with the resultant value of `v + 1`  at position 3:</p>
<br>

```{r, eval=FALSE}
i <- 3

v[i]

vNew[i] <- v[i] + 1

vNew[i]

v[i] + 1 == vNew[i]
```
<br>

<h3><i>For loop</i>, sequence</h3>
<br>
<p>The utility of the  <i>for loop</i> is that we can calculate the above for each position (`i`) in vector `v`. This is done by setting the "<b>for loop sequence</b>" statement which defines the locations over which the  <i>for loop</i> will be calculated. The <i>for loop</i> sequence for locations one through five is written as (<b>DO NOT RUN</b>):</p>
<br>

```{r for loop bad sequence, eval=FALSE}
# for(i in 1:5)
```
<br>

<p>The above can be translated as "for position <i>i</i> in positions one through five".</p>

<p>To make our code as flexible as possible, we generally do not want to have to directly type in the stopping point of the <i>for loop</i>. We can use `1:length(v)` or the function `seq_along` to specify the <i>for loop</i> address. Run the following and note the behavior:</p>

<br>
```{r seq_along, eval=FALSE}
v

1:5

1:length(v)

seq_along(v)
```
<br>

<p>The <i>for loop</i> sequence statement can then be written as (<b>DO NOT RUN</b>):</p>
<br>

```{r for loop sequence statements, eval=FALSE}
# Example for loop sequence statements:

# for(i in 1:length(v))
  
# for(i in seq_along(v))
```
<br>

<p>The above statements are more flexible than providing a numeric stopping point for your <i>for loop</i>.</p>

<h3><i>For loop</i>, body</h3>

<p>The <i>for loop</i> sequence statement is followed by the "<b>body</b>" statement that tells R what to do during each iteration of the loop. The body associated with our "add one" formula is (<b>DO NOT RUN</b>):</p>
<br>

```{r, eval=FALSE}
vNew[i] <- v[i] + 1
```
<br>

<p>If your for loop spans multiple lines, place the body within curly brackets, for example (<b>DO NOT RUN</b>):</p>
<br>

```{r, eval = FALSE}
# for(i in 1:length(x)){
#   body
# }
```
<br>

<h3>The complete <i>for loop</i></h3>
<br>
<p>Putting together our steps of: 1) Creating an <b>output</b> object, 2) The <i>for loop</i> <b>sequence</b> statement, and 3) The <b>body</b> statement, our completed  <i>for loop</i> is written as follows (<b>RUN THIS ONE</b>):</p>
<br>

```{r full example for loop, eval=FALSE}
vNew <- numeric(length = length(v))

for(i in seq_along(v)){
 vNew[i] <- v[i] + 1
}
```
<br>

<p>Take a look at the output and compare it with the values of `v`:</p>
<br>

```{r, eval=FALSE}
vNew

v

vNew == v
```

<br>
<div class = "roundBorderBlack">

<br>
<p><i class="fa fa-user-secret" aria-hidden="true" style = "font-size: 150%"></i> We specify the length of the vector to provide R with stopping rules -- without this  <i>for loops</i> can become very memory hungry when running over large datasets</p>
<hr>
<p><i class="fa fa-user-secret" aria-hidden="true" style = "font-size: 150%"></i> The following two sections of code are equivalent, but the latter much easier to read. As writing code is both a tool and a method of communication, you should ensure that your code is as readable as possible.</p>
<br>

```{r, eval = FALSE}

for(i in 1:length(v)) vNew[i] <- v[i] + 1

for(i in 1:length(v)){
  vNew[i] <- v[i] + 1
}
```
<hr>

<p><i class="fa fa-user-secret" aria-hidden="true" style = "font-size: 150%"></i> When writing  <i>for loops</i>, it is necessary to ensure that the loop is doing what you expect it to do. A simple way to ensure that this is the case is to specify <i>i</i> and run the <i>instructions</i> on just that value. For example, to observe the behavior of the  <i>for loop</i> at position 3:</p>
<br>

```{r, eval=FALSE}

i = 3

vNew[i] <- v[i] + 1

vNew[i]

v[i]

```
</div>

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Two:</h3>
<br>
<ol>
<li>Use a <i>for loop</i> to test whether each species of bird in the `birdHabits` data frame is an omnivore (logical test).</li>
<li>Calculate the total number of records associated with omnivorous birds.</li>
</ol>
<br>
</blockquote>
<br>
<hr>
<br>

<!--Using for loops for subsetting-->
<h2><i>For loop</i> application, summarizing data</h2>
<br>
<p>You may have noticed that none of the operations we completed in the previous section actually required for loops (for example, `v + 1` is calculated for each value of `v` by default). The Iris example at the start of this lesson, however, highlights their utility for summarizing data. Calculating the mean for each species without a <i>for loop</i> required the following code:</p>
<br>

```{r summarizing review, eval=FALSE}
# Mean petal lengths of Iris species without a for loop:

mean(irisTbl[irisTbl$species == 'setosa', ]$petalLength)

mean(irisTbl[irisTbl$species == 'versicolor', ]$petalLength)

mean(irisTbl[irisTbl$species == 'virginica', ]$petalLength)
```
<br>

<p>We can use a <i>for loop</i> to calculate this value across species. To do so, we first need to create a vector of species:</p>
<br>

```{r, eval=FALSE}
# Make a vector of species to loop across:

irisSpecies <- levels(irisTbl$species)

irisSpecies
```
<br>

<p>Next, we'll create an empty vector to store our <b>output</b>:</p>
<br>

```{r, eval=FALSE}
# For loop output statement:

petalLengths <- vector('numeric',length = length(irisSpecies))

petalLengths
```
<br>

<p>The vector of Iris species will define the bounds of our <i>for loop</i> <b>sequence</b> (<b>DO NOT RUN</b>):</p>
<br>

```{r, eval=FALSE}
# For loop sequence: 

# for(i in seq_along(irisSpecies))
```
<br>

<p>Our <i>for loop</i> body is constructed as:</p>
<br>

```{r, eval=FALSE}
# Exploring the construction of the for loop body:

i <- 3

irisSpecies[i]

irisTbl[irisTbl$species == irisSpecies[i], ]

irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength

mean(irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength)

# The for loop body:

petalLengths[i] <- mean(irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength)
```
<br>


<p>Putting it all together, the <i>for loop</i> would be written as:</p>
<br>

```{r, eval=FALSE}
# Make a vector of species to loop across:

irisSpecies <- levels(irisTbl$species)

# For loop output statement:

petalLengths <- vector('numeric',length = length(irisSpecies))

# For loop:

for(i in seq_along(irisSpecies)){
  petalLengths[i] <- mean(irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength)

}



```
<br>

<p>We can turn our result into a tidy tibble data frame, using the `data_frame` function:</p>
<br>

```{r summarizing putting it together, eval=FALSE}
petalLengthFrame <- data_frame(species = irisSpecies, count = petalLengths)

petalLengthFrame
```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Three:</h3>
<br>
<p>Use a <i>for loop</i> and the `birdHabits` data frame to calculate the number species in each diet guild.</p>
<br>
</blockquote>
<br>
<hr>
<br>

<h2>Generating number series with  <i>for loops</i></h2>

<p>We may also be interested in using a  <i>for loop</i> to generate a vector of numbers based on some mathematical operation. For example, consider we have a value, 10, and want to calculate the mathematical expression:</p>

$$n_t = 2(n_{t-1})$$

<p>We must first start with a "<b>seed</b>" value for our vector. This is the initial value of vector `n`.</p>
<br>

```{r number series 1, eval=FALSE}
n <- 10
```
<br>

<p>In this instance, because we will store our resultant values within the same vector, `n`, it is unnecessary to create a blank vector to store the results.</p>

<p>Let's calculate the first five values in this series. Because our  <i>for loop</i> starts with our seed value, we are only interested in the second through fifth positions of this vector. Thus, our for loop initialization statement is (<b>DO NOT RUN</b>):</p>
<br>

```{r number series 2, eval=FALSE}
for(i in 2:5)
```
<br>

<p>And our complete  <i>for loop</i> statement becomes:</p>
<br>

```{r number series 3, eval=FALSE}
n = 10

for(i in 2:5){
 n[i] = n*v[i-1]
}
```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Two:</h3>
<br>

<p>One of my favorite <i>for loops</i> was created by Leonardo Bonacci (Fibonacci). He created the first known population model, from which the famous Fibonacci number series was created. He described a population (N) at time t as the sum of the population at the previous time step plus the time step before that:</p>

$$N_t = N_{t-1} + N_{t-2}$$
<ol>
<li>Use the combine function to create a seed vector of two values, zero and one.</li>
<li>Use the formula above and your seed vector to generate the first 20 numbers of the Fibonacci number sequence. <i><b>Hint</b>: The for loop initialization will begin at third position -- it will <b>NOT</b> include all of 1:20!</i></li>
</ol>
</blockquote>
<br>
<hr>
<br>




<h2>**Functions**</h2>

<p>In the introductory lesson and above, we have worked with several functions (e.g., "c", "mean"). Functions allow you to simplify complex tasks, which is especially useful if you need to run a task multiple times. Program R contains many functions and many more still are created by R users and provided to the R community as collections of functions known as packages (or libraries). As datasets and data handling needs are often distinct, relying exclusively on built-in and community-defined functions may be limiting. Learning how to create your own functions, or customize existing functions, provides you with the flexibility to solve unique problems, shorten your script, and make your R code more legible for others.</p>

<p>Writing your own functions is easy, as long as you follow the correct syntax. The basic structure is:</p>
<br>

```{r, eval=FALSE}
theNameOfMyFunction <- function(objectToComputeFunctionFor) {
	What you would like to happen when you run your function
}
```
<br>

<p>Let's write a function that will do the same thing as our first for loop -- add 1 to every value in our vector V0.</p>
<br>

```{r, eval=FALSE}
addOneFun <- function(x){
	x+1
}
```
<br>

<p>Let's run the addOneFun function and compare it to our values in V1 above:</p>
<br>

```{r, eval=FALSE}
addOneFun(V0)

V1
```
<br>

----

> **Exercise Four:**
>
> The mathematical formula for standard error is provided below. Convert this to an R function (_**Note**: the function for standard deviation is "sd" and the function for square root is "sqrt"_):
> $$StdErr (x) = \frac{StDev(x)}{\sqrt{n}}$$

---

<h2>Subsetting data with functions</h2>

<p>In the  <i>for loops</i> section above, we subset the birdHabits frame by the aerial foraging guild using: </p>
<br>

```{r, eval=FALSE}
birdHabits[birdHabits$foraging == 'aerial',]
```
<br>

<p>If it is necessary to repeat this operation multiple times, we can simplify our scripts and make them more readable by wrapping our subsetting operation within a function. Below, we create a function that subsets by foraging guild and extract the data using the character value for that guild:</p>
<br>

```{r, eval=FALSE}
foragingSubsetFun <- function(foragingGuild){
 birdHabitsSubset <- birdHabits[birdHabits$foraging == foragingGuild,]
 return(birdHabitsSubset)
}

foragingSubsetFun('aerial')
```
<br>

<p>Likewise, we may be interested in calculating the _sum_ of counts for a given guild. Above we calculated the summed counts for a given guild as:</p>
<br>

```{r, eval=FALSE}
sum(birdHabits[birdHabits$foraging == 'aerial','count'])
```
<br>

<p>We can embed this line of code within a function to extract the sum of counts for a given foraging guild:</p>
<br>

```{r, eval=FALSE}
foragingSumFun <- function(foragingGuild){
 birdHabitsubset <- birdHabits[birdHabits$foraging == foragingGuild,'count']
 return(sum(birdHabitsubset))
}

foragingSumFun('aerial')
```
<br>

<p>We could also sum the count field by nesting the previous subsetting function within a new function:</p>
<br>

```{r, eval=FALSE}
foragingSumFun <- function(foragingGuild){
 birdHabitsubset <- foragingSubsetFun(foragingGuild)
 return(sum(birdHabitsubset$count))
}

foragingSumFun('aerial')
```
<br>

<p>We can make our subsetting and summing functions more flexible by allowing us to choose which trait (e.g., diet or foraging) and guild we would like to count:</p>
<br>

```{r, eval=FALSE}
traitGuildSubsetFun <- function(trait, guild){
 birdHabitsubset <- birdHabits[birdHabits[,trait] == guild,]
 return(birdHabitsubset)
}

traitGuildSumFun <- function(trait, guild){
 birdHabitsubset <- traitGuildSubsetFun(trait, guild)
 return(sum(birdHabitsubset$count))
}

traitGuildSumFun('foraging','aerial')

traitGuildSumFun('diet','insectivore')
```
<br>

----

> **Exercise Five:**
>
>1. Create a function that calculates the mean count for a given diet guild across sites. _**Hint**: Mean count is the sum of counts divided by the total number of sites in the birdHabits data frame. Do not use the built-in "mean"" function. Why can't we use the mean function?_ 
>
>2. Create a function that calculates the mean count for a selected trait (e.g. diet or foraging) and guild across sites.

----

<h2>**OPTIONAL CHALLENGE!**</h2>

<p>You can use  <i>for loops</i> and functions to examine fundamental theoretical models in ecology. (**Only**) If you're feeling super comfortable with  <i>for loops</i> and functions, try out these additional exercises:</p>

----

1. The species-area relationship of Arrhenius (1921) states that the number of species (_S_) is dependent on the rate of increase in species with increasing area (_z_) multiplied by a constant (_c_) that represents the number of species that would be present in one spatial unit. This model is summarized as: 
$$S = c \cdot\ A^z$$

  a. Convert the species-area relationship formula to an R function, with _c_, _A_, and _z_ set as unknowns.
  b. Create a vector named _areaVector_ of areas values ranging from 1 to 10.
  c. Using 15 for the value of c and a z of 0.75, use a  <i>for loop</i> to calculate the expected species richness for your _areaVector_. _Note: You don't really need to use a for loop for this, but it's good practice!_  

----
  
2. The exponential population growth model describes the growth of a population without resource limitations. This model describes the size of a population ($N_t$) at a given time unit as a function of the per capita growth rate of the population (_r_) and the size of the population at time _t_. This model is summarized as: 
$$N_t = N_0 \cdot e^{r \cdot t}$$

  a. Convert the exponential population growth model to an R function with _r_, $N_0$, and _t_ as unknowns.
  b. With an initial population size of 25 and a per capita growth rate (_r_) of 0.45, use the exponential population growth rate function and a  <i>for loop</i> to calculate the size of the population over 10 generations.  

----
  
3. The logistic population growth model (Verhulst) states that the growth of the population will be constrained by the population carrying capacity (_K_) as a function of resource limitations. This model is summarized as (_Note: the remaining variables are as above_):
$$N_t = \dfrac{K}{\mathstrut{1 + \bigg[ \dfrac{K-N_0}{N_0} \bigg] \cdot e^{-r \cdot t}}}$$

  a. Convert the logistic population growth model to an R function with _r_, $N_0$, t, and _K_ as unknowns. 
  b. With an initial population size of 25, a per capita growth rate (_r_) of 0.45, and a carrying capacity of 500 individuals, use the logistic population growth rate function and a  <i>for loop</i> to calculate the size of the population over 10 generations.

----



