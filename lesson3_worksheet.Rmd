---
output:
 html_document:
  theme: yeti
---

<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<style>

code{
  background-color:#f2f2f2;
  border-radius: 25px;
}
 
span.co{
  color:#000080;
  font-weight: bold;
}
 
img{
  display: block;
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 10px;
  padding-bottom: 10px;
}

p{
  text-align: left;
  font-size: 18px;
}

ul, ol{
  line-height: 27px;
  text-align: left;
  font-size: 18px;
  margin-left: 0px;
}
 
blockquote{
  font-size: 18px;
  border-left: 8px solid #292093;
  background-color: #e6ffff;
  padding-left: 16px;
  padding-right: 16px;
}
 
.row{
  margin: auto;
}
 
table {
  border-collapse: collapse;
}

table, td, th {
  border: 1px solid black;
  padding: 5px;
  text-align: center;
  vertical-align: middle;
}
 
 /* Create two equal columns that floats next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

.roundBorder {
  border-radius: 25px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlack {
  border-radius: 25px;
  border: 10px solid #D3D3D3;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlackEx {
  border-radius: 5px;
  border: 5px solid #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}

.roundBorderEx {
  border-radius: 3px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}


.tt {
    position: relative;
    display: inline-block;
    class: inline; 
    font-weight: bold;
    font-family: "Avenir";
    font-size: 18px;
    border-bottom: 1px black;
}

/* Tooltip text */
.tt .ttText {
    visibility: hidden;
    font-weight: normal;
    font-size: 18px;
    width: 200px;
    background-color: black;
    border: 1px solid black;
    color: white;
    text-align: left;
    padding: 5px;
    border-radius: 6px;
    position: absolute;
    z-index: 1;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tt:hover .ttText {
    visibility: visible;
}

</style>

<h1 style="text-align: center;">Introduction to data science in R, Lesson 3:<br/>Functinos and <i>for loops</i></h1>
<br>
<!img style="float: left; margin: 0px 0px 15px 15px;" src="nzpLogo.jpg" width="150" />
<p style = "text-align: center; font-size: 14px;">Brian S. Evans, Ph.D.<br />
Migratory Bird Center<br/>
Smithsonian Conservation Biology Institute</p>
<hr>

<p>In this lesson we will explore <b><i>for loops</i></b> and <b>functions</b>. A <b><i>for loop</i></b> is a block of code that allows you to repeat an operation a set number of iterations. A function is a set of code that allows you to create or modify objects in a repeatable way. As data analysis often includes many repeated tasks,  <i>for loops</i> and user-defined functions can save considerable time, shorten R scripts, and make your scripts more legible. Understanding how they work is crucial to developing good coding practices.</p>

</p>

<hr>

<h2>Setup for the lesson:</h2>

<p>For this lesson, we will use three example data frames: Iris sepal and petal measurements collected by botanist Edgar Anderson in the 1920's, bird traits collected by Wilman et al. (2014), and bird point count observations from Washington, DC (Evans et al. 2016).</p>

<p>Open R Studio and run the following lines of code to load the data into R:</p>
<br>

```{r, eval=FALSE}
#=================================================================================*
# ---- set up ----
#=================================================================================*

# Load libraries

library(RCurl)

library(tidyverse)

# Note: If you have yet to install these library, please do so with: 
# install.packages('rCurl') ; install.packages('tidyverse')

# Provide the web addresses of the files (note: iris is preloaded example data):

habitsURL <- getURL('https://raw.githubusercontent.com/bsevansunc/workshop_languageOfR/master/birdHabits.csv')

countsURL <- getURL('https://raw.githubusercontent.com/bsevansunc/workshop_languageOfR/master/birdCounts.csv')

# Read in the data:

birdHabits <- tbl_df(read.csv(text = habitsURL))

birdCounts <- tbl_df(read.csv(text = countsURL))

```

<br>
<p>Take a moment to explore the data:</p>
<br>

```{r, eval=FALSE}
# Explore the data (birdHabits example):

head(birdHabits)

dim(birdHabits)

attributes(birdHabits)

str(birdHabits)

summary(birdHabits)

```

<br>
<p>Have a look at the built-in iris dataset as well:</p>
<br>

```{r, eval=FALSE}
# Explore the iris data:

head(iris)

dim(iris)

attributes(iris)

str(iris)

summary(iris)
```

<br>
<p>For the iris dataset, I think it's best to do some familiar cleaning steps:</p>
<br>

```{r, eval=FALSE}

# Clean up iris for analysis:

irisTbl <- tbl_df(iris)

names(irisTbl) <-
  c('sepalLength',
    'sepalWidth',
    'petalLength',
    'petalWidth',
    'species')
```
<hr>

<h2>**Functions**</h2>

<p>In the previous lessons, we have worked with several functions (e.g., "c", "mean"). Functions allow you to simplify complex tasks, which is especially useful if you need to run a task multiple times. Program R contains many functions and many more still are created by R users and provided to the R community as collections of functions known as packages (or libraries). As datasets and data handling needs are often distinct, relying exclusively on built-in and community-defined functions may be limiting.</p>
<p><b>Why would you write your own functions?</b> Learning how to create your own functions, or customize existing functions, provides you with the flexibility to solve unique problems, shorten your script, and make your R code more legible for others. Writing your own functions is easy, as long as you follow the correct syntax. The basic structure is:</p>
<br>

```{r, eval=FALSE}
theNameOfMyFunction <- function(objectToComputeFunctionFor) {
	What you would like to happen when you run your function
}
```
<br>

<p>Let's illustrate writing functions with a pretty silly example -- a function that will add 1 to any value. Below, we assign a name to the function, `addOneFun <-`, tell R that the code in the enclosing curly brackets is a function of some object `x` (`function(x)`), and provide the argument the function will be evaluated and returned (`x + 1`). </p>
<br>

```{r, eval=FALSE}

# First function:

addOneFun <- function(x){
	x+1
}

# Testing the function on a numeric value:

42+1

addOneFun(42)

# Testing the function on a vector of numeric values:

v <- c(1,1,2,3,5)

v + 1

addOneFun(v)
```
<br>

<p>If you are doing a lot of data <b>querying</b>, writing your own query functions can be a great way to make your code more legible. Let's use the `birdCounts` data to explore writing custom query functions. For example, perhaps you frequently need to query the number of individuals of a given species at each site:</p>
<br>

```{r queryFun, eval = FALSE}

# Query by species function:

speciesSubset <- function(spp){
  birdCounts[birdCounts$species == spp, ]
}

# Test function:

birdCounts[birdCounts$species == 'grca', ]

speciesSubset('grca')

```
<br>
<p>It's best to write your functions as general as possible. For example, the species subset function above is great if you are going to query just the `birdCounts` data frame. If you also intend to query the `birdHabits` frame by species, you may want to make the data frame one of the arguments.</p>
<br>

```{r query generalize fun, eval = FALSE}

# Query by species function, generalized:

speciesSubset <- function(dfIn, spp){
  dfIn[dfIn$species == spp, ]
}

# Test function, birdCounts:

birdCounts[birdCounts$species == 'grca', ]

speciesSubset(birdCounts, 'grca')

# Test function, birdHabits:

birdHabits[birdHabits$species == 'grca', ]

speciesSubset(birdHabits, 'grca')
```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise One:</h3>
<br>
<ol>
<li>Write a function to subset the `birdHabits` data frame to just ground foraging birds.</li>
<li>Write a function that will calculate the total number of individuals observed of a given species in the `birdCounts` data frame(i.e., the sum of count for a data frame subset by species)</li>
</ol>
<br>
</blockquote>
<br>
<hr>
<br>

<p>Functions can sometimes get pretty long and include multiple objects. When this is the case, it's good practice to include `return` to illustrate which object is being returned. Let's write a function in multiple steps that calculates the average (mean) number of individuals of a given species observed on a point count.</p>

```{r query mean fun, eval = FALSE}

# Query by species function, generalized:

meanSpeciesCounts <- function(spp){
  # Number of unique site values:
  nSites <- length(unique(birdCounts$site))
  # Subset birdCounts to the species of interest:
  birdCounts_sppSubset <- birdCounts[birdCounts$species == spp, ]
  # Calculate the total number of birds observed:
  nBirds <- sum(birdCounts_sppSubset$count)
  # Return mean number of birds per site:
  return(nBirds/nSites)
}

# What is the average number of observed catbirds?

meanSpeciesCounts(birdCounts, 'grca')
```
<br>
<p>Functions can also be <b>nested</b>. In other words, functions can include user-defined functions written inside the function body. We have already done this quite a bit with functions in base R. For example, the `length` function above is nested inside our user-defined function `meanSpeciesCounts`. Let's try to nest our `speciesSubset` function inside the `meanSpeciesCounts` function above.</p>
<br>
```{r query mean fun2, eval = FALSE}

# Query by species function, generalized:

meanSpeciesCounts <- function(dfIn, spp){
  # Number of unique site values:
  nSites <- length(unique(dfIn$site))
  # Calculate the total number of birds observed:
  nBirds <- sum(speciesSubset(dfIn, spp)$count)
  # Return mean number of birds per site:
  return(nBirds/nSites)
}

# What is the average number of observed catbirds?

meanSpeciesCounts(birdCounts, 'grca')
```
<br>

<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Two:</h3>
<br>
<ol>
<li>Using the `birdHabits` data frame, write a function to count the number of species in a given diet and foraging guild.</li>
<li>The mathematical formula for standard error is provided below. Convert this to an R function (<b>Note</b>: the function for standard deviation is `sd` and the function for square root is `sqrt`):</li>
$$StdErr (x) = \frac{StDev(x)}{\sqrt{n}}$$
</ol>
<br>
</blockquote>
<br>
<hr>
<br>

<img src="rWorkshop/images/Iris_setosa.jpg" 
	title="Iris setosa"
	alt = "picture of the flower Iris setosa"
	border="0"
	style= "float: right; 
	      padding-right: 0px;
	      border-style: solid;
	      border-width: 10px;
	      border-color: white;
	      width: 30%;"/>
	      
<h2>**For loops**</h2>

<br>
<p><b>Why would you use <i>for loops</i>?</b> Let's look at a common example. You have been asked to calculate the mean petal length of three Iris species: <i>Iris setosa</i>, <i>Iris versicolor</i>, and <i>Iris virginica</i>.  (coded as the factor levels `setosa`, `versicolor`, and `virginica` in the `species` field of the `irisTbl` data frame). Using the `mean` function and tools that we have addressed thus far, use the following to calculate the mean petal length for each species:</p>
<br>
```{r, eval=FALSE}
# Filter irisTbl to setosa:

irisTbl[irisTbl$species == 'setosa', ]

# Extract the petalLength field (column):

irisTbl[irisTbl$species == 'setosa', ]$petalLength

# Calculate the mean of petal lengths:

mean(irisTbl[irisTbl$species == 'setosa', ]$petalLength)

```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise One:</h3>
<br>
<p>Calculate the mean petal length of each of the Iris species using matrix notation (as above) and a custom function.</p>
<br>
</blockquote>
<br>

<p>The code you generated above is very repetitive -- the only change in each of the lines you should have created above was the name of the species. Writing code like this makes your scripts unnecessarily long and prone to user input error. <b><i>For loops</i></b> should be used whenever a chunk of code is repeated more than twice.</p>

<p>We'll return to the Iris example a bit later, but for now let's start with a very simple <i>for loop</i>.</p> 
<br>
<hr>

<p>Writing proper <i>for loops</i> requires following these three steps:</p>
<br>

<ol>
<li><b>Output</b>: Always define an object for storing output (e.g., an empty vector, matrix, or list)</li>
<li><b>Sequence</b>: The locations for which the loop will run</li>
<li><b>Body</b>: This is the instructions for what will occur during each iteration of the loop</li>
</ol>

<br>

<p>Let's use some example data. We'll construct a vector, `v`  using a set of five numbers. </p>
<br>

```{r, eval=FALSE}
v <- c(1,1,2,3,5)
v
```
<br>

<p>We would like to modify the values in vector `v` by adding one to each value. This might be written mathematically as:<br>

$$V_{new, i} = V_{i} + 1$$
</p>
<br>

<p>Recall that value `v[i]` is equal to the value at position <i>i</i> in vector `v`. Let's take a look at the value of `v` at position 3:</p>
<br>

```{r, eval=FALSE}

v[3]

i <- 3

v[i]

v[3] == v[i]
```
<br>


<p>If we want to calculate `v + 1` at position 3, we would write:</p>
<br>

```{r, eval=FALSE}
v[3] + 1
```

<hr>

<h3><i>For loop</i>, output:</h3>

<br>
<p><i>For loop</i> development begins by defining an object of a given length that your <i>for loop</i> will write to. This step is <b>very important</b> -- your <i>for loop</i> will run much, much slower if you do not do so!</p>

<br>
<p>Vector objects are defined as follows:</p>
<br>

```{r, eval=FALSE}
vNew <- vector('numeric', length = length(v))

str(vNew)
```

<br>
<p>The first argument of the `vector` function is the type of object you would like to create. The next argument sets the length of the created object to be the equivalent to that of `v`.</p>
<br>

<p>Values of vector `vNew` will be replaced location-by-location. For example, let's compare the initial value of `v` with the resultant value of `v + 1`  at position 3:</p>
<br>

```{r, eval=FALSE}
i <- 3

v[i]

vNew[i] <- v[i] + 1

vNew[i]

v[i] + 1 == vNew[i]
```
<br>

<h3><i>For loop</i>, sequence</h3>
<br>
<p>The utility of the  <i>for loop</i> is that we can calculate the above for each position (`i`) in vector `v`. This is done by setting the "<b>for loop sequence</b>" statement which defines the locations over which the  <i>for loop</i> will be calculated. The <i>for loop</i> sequence for locations one through five is written as (<b>DO NOT RUN</b>):</p>
<br>

```{r for loop bad sequence, eval=FALSE}
# for(i in 1:5)
```
<br>

<p>The above can be translated as "for position <i>i</i> in positions one through five".</p>

<p>To make our code as flexible as possible, we generally do not want to have to directly type in the stopping point of the <i>for loop</i>. We can use `1:length(v)` or the function `seq_along` to specify the <i>for loop</i> address. Run the following and note the behavior:</p>

<br>
```{r seq_along, eval=FALSE}
v

1:5

1:length(v)

seq_along(v)
```
<br>

<p>The <i>for loop</i> sequence statement can then be written as (<b>DO NOT RUN</b>):</p>
<br>

```{r for loop sequence statements, eval=FALSE}
# Example for loop sequence statements:

# for(i in 1:length(v))
  
# for(i in seq_along(v))
```
<br>

<p>The above statements are more flexible than providing a numeric stopping point for your <i>for loop</i>.</p>

<h3><i>For loop</i>, body</h3>

<p>The <i>for loop</i> sequence statement is followed by the "<b>body</b>" statement that tells R what to do during each iteration of the loop. The body associated with our "add one" formula is (<b>DO NOT RUN</b>):</p>
<br>

```{r, eval=FALSE}
vNew[i] <- v[i] + 1
```
<br>

<p>If your for loop spans multiple lines, place the body within curly brackets, for example (<b>DO NOT RUN</b>):</p>
<br>

```{r, eval = FALSE}
# for(i in 1:length(x)){
#   body
# }
```
<br>

<h3>The complete <i>for loop</i></h3>
<br>
<p>Putting together our steps of: 1) Creating an <b>output</b> object, 2) The <i>for loop</i> <b>sequence</b> statement, and 3) The <b>body</b> statement, our completed  <i>for loop</i> is written as follows (<b>RUN THIS ONE</b>):</p>
<br>

```{r full example for loop, eval=FALSE}
vNew <- numeric(length = length(v))

for(i in seq_along(v)){
 vNew[i] <- v[i] + 1
}
```
<br>

<p>Take a look at the output and compare it with the values of `v`:</p>
<br>

```{r, eval=FALSE}
vNew

v

vNew == v
```

<br>
<div class = "roundBorderBlack">

<br>
<p><i class="fa fa-user-secret" aria-hidden="true" style = "font-size: 150%"></i> We specify the length of the vector to provide R with stopping rules -- without this  <i>for loops</i> can become very memory hungry when running over large datasets</p>
<hr>
<p><i class="fa fa-user-secret" aria-hidden="true" style = "font-size: 150%"></i> The following two sections of code are equivalent, but the latter much easier to read. As writing code is both a tool and a method of communication, you should ensure that your code is as readable as possible.</p>
<br>

```{r, eval = FALSE}

for(i in 1:length(v)) vNew[i] <- v[i] + 1

for(i in 1:length(v)){
  vNew[i] <- v[i] + 1
}
```
<hr>

<p><i class="fa fa-user-secret" aria-hidden="true" style = "font-size: 150%"></i> When writing  <i>for loops</i>, it is necessary to ensure that the loop is doing what you expect it to do. A simple way to ensure that this is the case is to specify <i>i</i> and run the <i>instructions</i> on just that value. For example, to observe the behavior of the  <i>for loop</i> at position 3:</p>
<br>

```{r, eval=FALSE}

i = 3

vNew[i] <- v[i] + 1

vNew[i]

v[i]

```
</div>

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Two:</h3>
<br>
<ol>
<li>Use a <i>for loop</i> to test whether each species of bird in the `birdHabits` data frame is an omnivore (logical test).</li>
<li>Calculate the total number of records associated with omnivorous birds.</li>
</ol>
<br>
</blockquote>
<br>
<hr>
<br>

<!--Using for loops for subsetting-->
<h2><i>For loop</i> application, split-apply-combine</h2>
<br>
<p>You may have noticed that none of the operations we completed in the previous section actually required <i>for loops</i> (for example, `v + 1` is calculated for each value of `v` by default). <i>For loops</i> are predominantly used to split-apply-combine data. In data science, split-apply-combine problems are those that relate to situations in which you seek to split a dataset into multiple parts, apply a function to each part, and combine the resulting parts. <i>For loops</i> can be a great tool for split-apply-combine problems.</p>

 The Iris example at the start of this lesson, however, highlights their utility for summarizing data. Calculating the mean for each species without a <i>for loop</i> required the following code:</p>
<br>

```{r summarizing review, eval=FALSE}
# Mean petal lengths of Iris species without a for loop:

mean(irisTbl[irisTbl$species == 'setosa', ]$petalLength)

mean(irisTbl[irisTbl$species == 'versicolor', ]$petalLength)

mean(irisTbl[irisTbl$species == 'virginica', ]$petalLength)
```
<br>

<p>We can use a <i>for loop</i> to calculate this value across species. To do so, we first need to create a vector of species:</p>
<br>

```{r, eval=FALSE}
# Make a vector of species to loop across:

irisSpecies <- levels(irisTbl$species)

irisSpecies
```
<br>

<p>Next, we'll create an empty vector to store our <b>output</b>:</p>
<br>

```{r, eval=FALSE}
# For loop output statement:

petalLengths <- vector('numeric',length = length(irisSpecies))

petalLengths
```
<br>

<p>The vector of Iris species will define the bounds of our <i>for loop</i> <b>sequence</b> (<b>DO NOT RUN</b>):</p>
<br>

```{r, eval=FALSE}
# For loop sequence: 

# for(i in seq_along(irisSpecies))
```
<br>

<p>Our <i>for loop</i> body is constructed as:</p>
<br>

```{r, eval=FALSE}
# Exploring the construction of the for loop body:

i <- 3

irisSpecies[i]

irisTbl[irisTbl$species == irisSpecies[i], ]

irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength

mean(irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength)

# The for loop body:

petalLengths[i] <- mean(irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength)
```
<br>


<p>Putting it all together, the <i>for loop</i> would be written as:</p>
<br>

```{r, eval=FALSE}
# Make a vector of species to loop across:

irisSpecies <- levels(irisTbl$species)

# For loop output statement:

petalLengths <- vector('numeric',length = length(irisSpecies))

# For loop:

for(i in seq_along(irisSpecies)){
  petalLengths[i] <- mean(irisTbl[irisTbl$species == irisSpecies[i], ]$petalLength)

}



```
<br>

<p>We can turn our result into a tidy tibble data frame, using the `data_frame` function:</p>
<br>

```{r summarizing putting it together, eval=FALSE}
petalLengthFrame <- data_frame(species = irisSpecies, count = petalLengths)

petalLengthFrame
```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Three:</h3>
<br>
<p>Use a <i>for loop</i> and the `birdHabits` data frame to calculate the number species in each diet guild.</p>
<br>
</blockquote>
<br>
<hr>

----

<p>To illustrate how this would work, we will use `birdCounts` data frame and calculate the total number of omnivorous birds that were observed at each of the sites. Take a moment to explore the data, we will need to use both data frames:</p>
<br>

```{r birdCounts0, eval = FALSE}
# Explore the bird count data:

head(birdCounts)

str(birdCounts)

# Explore the bird trait data:

head(birdHabits)

str(birdHabits)

```

<br>
<p>Our first goal will be to get a vector of birds that are ground foragers.</p>
<br>

```{r birdCounts1, eval = FALSE}
# Explore the bird count data:

omnivores <- birdHabits[birdHabits$diet == 'omnivore',]$species

```

<br>
<p><b>Split</b>: To evaluate the number of omnivores per site, we will <b>split</b> the data into individual sites. To do so, we generate a vector of unique sites and query the data frame by the site at a given position in the site vector.</p>
<br>

```{r birdCounts split, eval = FALSE}
# Generate a vector of unique sites:

sites <- unique(birdCounts$site)

# Site at position i:

i <- 3

sites[i]

# Subset data:

birdCounts_siteSubset <- birdCounts[birdCounts$site == sites[i],]

birdCounts_siteSubset

```

<br>
<p><b>Apply</b>: We then apply a function to each individual part. In this case, we will use `%in%` to extract only records associated with omnivores and sum the `count` field.</p>
<br>

```{r birdCounts apply, eval = FALSE}
# Just a vector of counts:

countVector <- birdCounts_siteSubset[birdCounts_siteSubset$species %in% omnivores, ]$count

# Get total number of omnivores at the site:

nOmnivores <- sum(countVector)

```

<br>
<p><b>Combine</b>: Output may be combined together as we have with previous <i>for loop</i> statements in this lesson. In the code below, I have combined the `sites` and `nOmnivore` vectors into a tibble data frame:</p>
<br>

```{r birdCounts combine1, eval = FALSE}
# Generate a vector of unique sites:

sites <- unique(birdCounts$site)

outVector <- vector('numeric', length = length(unique(sites)))

for(i in seq_along(sites)){
  birdCounts_siteSubset <- birdCounts[birdCounts$site == sites[i],]
  countVector <- birdCounts_siteSubset[birdCounts_siteSubset$species %in% omnivores, ]$count
  outVector[i] <- sum(countVector)
}

# Combine:

data_frame(site = sites, nOmnivores = outVector)
```

<br>
<p>An alternative to combining vectors that I often find useful is combining a list of data frames using the `tidyverse` function `bind_rows`:</p>
<br>

```{r birdCounts combine2, eval = FALSE}
# Generate a vector of unique sites:

sites <- unique(birdCounts$site)

outList <- vector('list', length = length(unique(sites)))

for(i in seq_along(sites)){
  birdCounts_siteSubset <- birdCounts[birdCounts$site == sites[i],]
  countVector <- birdCounts_siteSubset[birdCounts_siteSubset$species %in% omnivores, ]$count
  outList[[i]] <- data_frame(site = sites[i], nOmnivores = sum(countVector))
}

# Combine:

bind_rows(outList)
```


<hr>
<h2><i>For loop</i> application, simulation</h2>
<br>
<p>We may also be interested in using a  <i>for loop</i> to generate a vector of numbers based on some mathematical operation. For example, consider we have a value, 10, and want to calculate the mathematical expression:</p>

$$n_t = 2(n_{t-1})$$
<br>
<p>Let's start by creating a vector of length 5 for our <b>output</b>:
<br>

```{r number series 0, eval=FALSE}
# For loop output statement:


n <- vector('numeric', length = 5)

n
```

<p>We must first start with a "<b>seed</b>" value for our vector. This is the initial value of vector `n`.</p>
<br>

```{r number series 1, eval=FALSE}
# Setting the seed value:

n[1] <- 10

n
```
<br>

<p>Let's calculate the first five values in this series. Because our  <i>for loop</i> starts with our seed value, we are only interested in the second through fifth positions of this vector. Thus, our for loop <b>sequence</b> statement is (<b>DO NOT RUN</b>):</p>
<br>

```{r number series 2, eval=FALSE}
# For loop sequence:

# for(i in 2:length(n))
```
<br>

<p>For each iteration, the following <b>body</b> statement will be evaluated (the example is at position 2):
<br>
```{r number series 3, eval=FALSE}

# Exploring the construction of the for loop body:

i <- 2

n[i]

n[i-1]

n[i] <- 2*n[i-1]

n
```

<p>And our complete  <i>for loop</i> statement becomes:</p>
<br>

```{r number series 4, eval=FALSE}
# Output:

n <- vector('numeric', length = 5)

# Seed:

n <- 10

# For loop:

for(i in 2:5){
 n[i] = n*v[i-1]
}
```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Four:</h3>
<br>

<p>One of my favorite <i>for loops</i> was created by Leonardo Bonacci (Fibonacci). He created the first known population model, from which the famous Fibonacci number series was created. He described a population (N) at time t as the sum of the population at the previous time step plus the time step before that:</p>

$$N_t = N_{t-1} + N_{t-2}$$
<ol>
<li>Use the combine function to create a seed vector of two values, zero and one.</li>
<li>Use the formula above and your seed vector to generate the first 20 numbers of the Fibonacci number sequence. <i><b>Hint</b>: The for loop initialization will begin at third position -- it will <b>NOT</b> include all of 1:20!</i></li>
</ol>
</blockquote>
<br>
<hr>
<br>


<h2>**OPTIONAL CHALLENGE!**</h2>

<p>You can use  <i>for loops</i> and functions to examine fundamental theoretical models in ecology. (**Only**) If you're feeling super comfortable with  <i>for loops</i> and functions, try out these additional exercises:</p>

----

1. The species-area relationship of Arrhenius (1921) states that the number of species (_S_) is dependent on the rate of increase in species with increasing area (_z_) multiplied by a constant (_c_) that represents the number of species that would be present in one spatial unit. This model is summarized as: 
$$S = c \cdot\ A^z$$

  a. Convert the species-area relationship formula to an R function, with _c_, _A_, and _z_ set as unknowns.
  b. Create a vector named _areaVector_ of areas values ranging from 1 to 10.
  c. Using 15 for the value of c and a z of 0.75, use a  <i>for loop</i> to calculate the expected species richness for your _areaVector_. _Note: You don't really need to use a for loop for this, but it's good practice!_  

----
  
2. The exponential population growth model describes the growth of a population without resource limitations. This model describes the size of a population ($N_t$) at a given time unit as a function of the per capita growth rate of the population (_r_) and the size of the population at time _t_. This model is summarized as: 
$$N_t = N_0 \cdot e^{r \cdot t}$$

  a. Convert the exponential population growth model to an R function with _r_, $N_0$, and _t_ as unknowns.
  b. With an initial population size of 25 and a per capita growth rate (_r_) of 0.45, use the exponential population growth rate function and a  <i>for loop</i> to calculate the size of the population over 10 generations.  

----
  
3. The logistic population growth model (Verhulst) states that the growth of the population will be constrained by the population carrying capacity (_K_) as a function of resource limitations. This model is summarized as (_Note: the remaining variables are as above_):
$$N_t = \dfrac{K}{\mathstrut{1 + \bigg[ \dfrac{K-N_0}{N_0} \bigg] \cdot e^{-r \cdot t}}}$$

  a. Convert the logistic population growth model to an R function with _r_, $N_0$, t, and _K_ as unknowns. 
  b. With an initial population size of 25, a per capita growth rate (_r_) of 0.45, and a carrying capacity of 500 individuals, use the logistic population growth rate function and a  <i>for loop</i> to calculate the size of the population over 10 generations.

----



