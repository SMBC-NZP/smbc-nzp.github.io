---
output: html_document
---

---
output: 
  html_document:
    self_contained: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Set up ------------------------------------------------------------------

# The package is located online, not on CRAN:

source('https://raw.githubusercontent.com/cran/sigloc/master/R/sigloc.R')

# Some additional functions are needed:

source('https://www.dropbox.com/s/t4bxf2olztv8alx/packages_and_setup.R?dl=1')

# Additional packages we will be using for this lab:

library(tidyverse)
library(lubridate)
library(marked)
library(kableExtra)

# Load data:

sites <-
  read_csv('https://www.dropbox.com/s/wepk383tdqv54oo/sites.csv?dl=1')

bandingRecords <-
  read_csv('https://www.dropbox.com/s/fxiyavgbmwtfmrz/bandingRecords.csv?dl=1')#  %>%
  # filter(sex != 'noData') %>%
  # filter(!is.na(sex)) %>%
  # group_by(bandNumber) %>%
  # filter(!(enc != 'B' & date == min(date))) %>%
  # filter(!bandNumber == '2251-80348') %>%
  # ungroup %>%
  # write_csv('bandingRecords.csv')

resights <-
  read_csv('https://www.dropbox.com/s/psp8ssrwwopaz5l/resights.csv?dl=1') #%>%
  # filter(bandNumber %in% bandingRecords$bandNumber) %>%
  # write_csv('resights.csv')
```

<head>
<link rel="stylesheet" type="text/css" href="styles.css">
</head>

<img style="float:right;padding-left:25px;border:none" src="images/smsc_logo.jpg" width = "500px"/>

# Light-Level geolocator analysis using the GeoLight package
<p><i>Hallworth, M.T. and B.S. Evans</i><br>
Smithsonian Conservation Biology Institute<br>
Migratory Bird Center
</p>

<img src="http://www.lotek.com/images/bas-mk.jpg" height="175px" width="525px"/> <img src="http://mthallworth.weebly.com/uploads/1/8/3/8/18383927/2593529_orig.jpg" height = "150px" width= "150px"/>

## Introduction to Archival light-level geolocators
<p>The following document outlines the steps for analyzing data from archival light-level geolocators (hereafter geolocators). Geolocators have been used to track individuals since the early 1990s but were restricted to large organisms because of their large size. Recently, with the miniturization of geolocators, researchers are now able to deploy geolocators on smaller and smaller species.  Geolocators are devices that record ambient light levels every 2, 5, or 10 min depending on the model. Geolocators are attached to individuals which then migrate with the device while it records ambient light-levels throughout the year. Once recovered, the data are downloaded and analyzed to determine the time of sunrise and sunset. From the sunrise/sunset data the time of relative noon and midnight are determine. Geographical cooridnates are then derived from the relative 'noon' and 'midnight' times to give an approximate location of where the individual was throughout the year.</p>

<p>This tutorial uses geolocator data from a male Ovenbird (*Seiurus aurocapilla*) breeding at Hubbard Brook Experimental Forest, NH and a Wood Thrush (*Hylocichla mustelina*) breeding in Indiana and is part of an ongoing study modeling regional source-sink dynamics of a migratory songbird. Click [here](http://nationalzoo.si.edu/scbi/migratorybirds/research/marra/wood-thrush.cfm) for more information regarding the Wood Thrush project. The geolocators used for the two projects were purchased from [British Antarctic Survey](http://www.antarctica.ac.uk/bas_research/instruments/instrument7.php) (BAS) and [Lotek](htt://www.lotek.com/archival-birds.html) (LightBug). These models operate in the same manner but format the data differently. In order to use `GeoLight` to analyze the data, the data needed to be formatted correctly so `GeoLight` can read the data.</p>

## Set up

<p>Let's start by removing all of the items in your global environment. Do so using the following code:</p>
```{r}
rm(list = ls())
```
<br>
<p>The data format of geolocators purchased from different vendors are slightly different and need to be converted into a file format that is recognized by `GeoLight`. We wrote the custom functions `read_lig()` to read **British Antarctic Survey (.lig)** files and `read_lightBug()` to read the files generated by <i>Lotek Light Bug</i> device files (.txt). To load these functions, run the following script (<i>Note: the code below may take a long time to run if several packages need to be installed.</i>):<p>

```{r}
library(RCurl)

source('https://www.dropbox.com/s/t4bxf2olztv8alx/packages_and_setup.R?dl=1')
```
<br>

<p>Note that your global environment now includes the functions `read_lig()` and `read_lightBug()`. These functions simply format the files. For the purposes of this tutorial, you do not to need how the functions are constructed, but if you're curious you can click on their names in the Environment pane to view the details of the functions.</p>

<p>The following R packages need to be loaded to conduct the tutorial:</p>

```{r packages, message=FALSE, warning=FALSE}
library(GeoLight)
library(maps)
library(raster)
library(ks)
library(RColorBrewer)
```
<br>

### Read in the data

<p>Ovenbird data from **British Antarctic Survey**:</p>
```{r}
oven <-
  read_lig('https://www.dropbox.com/s/9qr0wl7zb2jdzwt/oven.lig?dl=1') 
```
<br>
<p>Wood thrush data from <i>Lotek LightBug</i> devices:</p>

```{r}
woth <-
  read_lightBug('https://www.dropbox.com/s/e69h0og3mwdwafv/woth.txt?dl=1') 
```

### Explore the data:

<p>Take a moment to explore the data ... for example, what does each column represent and how is it formatted?</p>

```{r}
head(oven)

head(woth)

str(oven)

str(woth)
```

## Determine transitions

Now that the data are formatted - you can use `GeoLight` to determine transitions (sunrise/sunset)

In this example - a threshold of 5 was used - a larger or smaller value can be used but it will decrease/increase the number of transitions that need to be scored.

`LightThreshold` - determines light levels over 5 as "sun has risen/set" and asks you to accept/reject them.

**Note - determining the transitions in this file took approx. 45mins - 1hr**  

The following code produces an interactive plot which asks the user to either accept or reject each light transition that passes over the threshold specified in the code. This document does not support interactive plots but the plot you will see should look similar to the one below. The blue line identifies the threshold level set in the code.

```{r message=FALSE, warning=FALSE, cache=TRUE,cache.path=paste0(getwd(),"/Hallworth_cache/GeoLight/")}
oven_transitions <-
  twilightCalc(
    datetime = oven[,2],
    light= oven[,4],
    LightThreshold=1,    # Here is where you set the threshold level
    ask=FALSE)           # Here you can go through every twilight
```

```{r echo=FALSE}
plot(
  oven[10000:11000,4]~oven[10000:11000,2],
  type="l",
  xlab="Time",
  ylab="light")
abline(h=1,col="blue",lty=2)
```
  
***
> **Exercise One:**
> Using indexing (i.e., data[x, y]), subset the oven data to the first 30 records and assign the name `oven_sub` to the resultant object.
> Go through and assign a few twilights.  
> *  How did you decide to either accept or reject twilight events?  
> *  How do you think accepting / rejecting twilight events would influence the end result?
> *  Change the threshold to a higher value - how does that change the number of shading events?

***
<br>

Once you have gone through the process of accepting or rejecting the transition events the data will look like this. `tFirst` and `tSecond` correspond to the time of the transitions and type illustrates whether the location will be dervied from relative 'noon' or 'midnight' locations. 

```{r}
head(oven_transitions)
```

## Sun-elevation angle

The next step is to calculate the sun-elevation angle of a known capture location. The sun-elevation angle is the angle of the sun with respect to the horizon at the time the geolocator light data passed the threshold set by the user. Thus, the sun-elevation angle is unique to the threshold used in the analysis. 

<img src="images/sunangleCartoon.png" height="300px" width="350px"/> <img src="images/sunangleCartoonResult.png" height="300px" width="350px"/>  

Here I chose the dates between deployment of the geolocator and July 31 to ensure that only transitions when the bird was at the capture location were used to calculate the sun-elevation angle. 

*The coordinates also need to be entered - (X,Y) in that order*

*This Ovenbird was captured at Hubbard Brook Experimental Forest, NH (-71.45,43.945)*  
 
```{r}
oven_breeding <-
  oven_transitions %>%
  filter(tFirst < '2012-07-31')

SunElev <-
  getElevation(
    tFirst = oven_breeding$tFirst,
    tSecond = oven_breeding$tSecond,
    type = oven_breeding$type,
    known.coord = c(-71.45,43.945),
    plot=TRUE)

SunElev
```

### Location estimates assuming no change in sun elevation angle throughout the year  

<p>We can now use the function `coord` which will estimate the location of observations from consecutive twilights:</p>

```{r}
ovenLocations <-
  coord(
    tFirst= oven_transitions$tFirst,
    tSecond= oven_transitions$tSecond,
    type=oven_transitions$type, 
    degElevation = SunElev)

head(ovenLocations)
```

<p>The values returned are a matrix of `lon` (longitude) and `lat` (latitude), as the first and second columns. Let's convert this object into a data frame and bring in the date of observation:</p>

```{r}
ovenLocations <-
  coord(
    tFirst= oven_transitions$tFirst,
    tSecond= oven_transitions$tSecond,
    type=oven_transitions$type, 
    degElevation = SunElev) %>%
  as.data.frame %>%
  bind_cols(
    oven_transitions
  )

head(ovenLocations)
```

#### Plot the location data

Note - We accepted all twilights with the original .lig file. That file includes all transtions the geolocator recorded. Therefore, it may include transitions before it was attached to the bird, or after it was taken off.
```{r}
plot(
  ovenLocations, 
  pch="*", 
  col="red",
  xlab="Longitude",
  ylab="Latitude")

map(
  'world',
  add = TRUE)
```

***
> #### Exercise Two:
> <p>There are some extreme outliers in the data. Take a look at the species distribution of the Ovenbird at this <a href = 'https://www.allaboutbirds.org/guide/ovenbird' target = "_blank"><b>link</b></a>. Use this information to filter the geolocator output to points that are reasonable (<i>Hint: use the tidyverse function `filter`</i>). Assign the name `ovenLocations_sub` to the resultant object.</p>
***

```{r, echo = FALSE}
ovenLocations_sub <-
  ovenLocations %>%
  filter(
    between(lon, -140, -50),
    between(lat, 6, 68))
```

#### Create Kernel Density Estimates (KDE) around the stationary periods 

Breeding locations were determined using location data described earlier in determining the sun-elevation angle. The non-breeding period determined as 1 November - 3 March (the start of spring Equinox period). See [Hallworth et al. 2015](https://www.researchgate.net/publication/273131898_Migratory_connectivity_of_a_Neotropical_migratory_songbird_revealed_by_archival_light-level_geolocators) for details.

```{r}
breeding_oven <-
  ovenLocations_sub %>%
  filter(tFirst < '2011-07-31')

NB_oven <-
  ovenLocations_sub %>%
  filter(
    tFirst > '2011-10-31',
    tFirst < '2012-03-03'
  )
  
```
<br>
<p>Determine bandwidth for the Kernel density estimate - the bandwidth parameter sets the 'smoothness' of the KDE. The bandwidth was estimated using least-square cross validation.</p>

```{r}
Bwidth <- 
  Hlscv(breeding_oven[,1:2])

NBwidth <-
  Hlscv(NB_oven[,1:2])
```
<br>
The following script creates the KDE and converts the KDE to a raster:
```{r}
Breeding_KDE <- 
  breeding_oven[,1:2] %>%
  kde(H = Bwidth) %>%
  raster

NonBreeding_KDE <- 
  NB_oven[,1:2] %>%
  kde(H = NBwidth) %>%
  raster
```
<br>
<p>For better viewing, we can set values with a KDE of zero to NA as below:</p>
```{r}
Breeding_KDE[values(Breeding_KDE) == 0] <- 
  NA

NonBreeding_KDE[values(NonBreeding_KDE) == 0] <- 
  NA
```


<br>
<p>We will next set breaks (similar to the breaks in the histograms in the distance lab)to color the KDE for the breeding and non-breeding periods similarly:</p>

```{r}
Breed.breaks <-
  seq(
    from = 0,
    to = maxValue(Breeding_KDE),
    (maxValue(Breeding_KDE) / 100))

NB.breaks <-
  seq(
    from = 0,
    to = maxValue(NonBreeding_KDE),
    (maxValue(NonBreeding_KDE) / 100))
```

<br>
<p>We will use RColorBrewer to make a color palette for coloring our KDE:
```{r}
colorPal <-
  colorRampPalette(brewer.pal(9,"Blues"))(100)
```
<br>

<p>To plot the data, we should first determine the appropriate extent for our plot window. Let's define the extent based on the two KDEs and create a new extent object called `plotExtent` (<i>Note: extent can be defined as `extent(xMin, xMax, yMin, yMax)`</i>):</p>

```{r}
extent(Breeding_KDE)

extent(NonBreeding_KDE)
```

```{r, echo = FALSE}
plotExtent <-
  extent(-78, -64, 9, 47)
```

<p>Plot the results (*not elegant but you can dress it up from here anyway you want*):</p>

```{r}
plot(plotExtent)

plot(
  Breeding_KDE,
  axes=FALSE,
  breaks=Breed.breaks,
  col=colorPal,
  legend=FALSE, 
  add = TRUE)

plot(
  NonBreeding_KDE,
  axes=FALSE,
  breaks=NB.breaks,
  col=colorPal,
  legend=FALSE,
  add=TRUE)

map(
  'world',
  add=TRUE)
```


***
> #### Exercise Three:
> Plot the mean and median location for the non-breeding period (Nov 1 - March 31). 
>
> The locations are in the object ovenLocations which has two columns without headers.  
> The first column (ovenLocations[,1]) is the longitude column.  
> The corresponding rows in the data for Nov 1 and March 31 are rows 287 & 590.  
>
> * Do your conclusions about where the bird wintered change based on how you plot the data (mean, median, kernel density estimate)?  
> * How might your conclusions change if the bird wintered in South America and not in the Caribbean. Would the way you present the data change your conclusions about where the bird wintered? 

***
```{r echo=FALSE}
meanLocs<-apply(ovenLocations[287:590,],2,mean,na.rm=TRUE)
medianLocs<-apply(ovenLocations[287:590,],2,median,na.rm=TRUE)
MEAN<-SpatialPoints(cbind(meanLocs[1],meanLocs[2]))
MEDIAN<-SpatialPoints(cbind(medianLocs[1],medianLocs[2]))

plot(ovenLocations, 
     pch="*", 
     col="gray",
     xlab="Longitude",
     ylab="Latitude",
     ylim=c(7,30),
     xlim=c(-90,-60))

plot(NonBreeding_KDE,
     axes=FALSE,
     breaks=NB.breaks,
     col=colorRampPalette(brewer.pal(8.75,"Blues"))(100),
     legend=FALSE,
     add=TRUE)

plot(MEAN,add=TRUE,pch=19,col="black")
plot(MEDIAN,add=TRUE,pch=17,col="red")
plot(world,add=TRUE)
legend(-70,25,legend=c("Mean","Median"),pch=c(19,17),col=c("black","red"),bty="n")
```
  
#### Using different sun-elevation angles for different periods of the annual cycle

<p>Notice in the above figure how the non-breeding KDE is exclusively over the Caribbean and does not fall over land. The sun-elevation angle (described above) can make a big difference in the latitude of the locations. The sun-elevation angle can be influenced by a variatey of factors such as habitat type, topography, weather, and bird behavior. Thus, using multiple sun-elevation angles for different portions of the year may be justified. The following code demonstrates how the sun-elevation angle for different portions of the year can be determined. Few studies have in-habitat calibrations for both breeding and non-breeding periods of the year (but see Hallworth et al. 2015, Stanley et al. 2014, McKinnon et al. 2013). Thus the sun-elevation angle for different portions of the year need to be estimated. In `GeoLight` there is a function called `HillEkstromCalib` which determines the sun-elevation angle based on the transition events in the data. 

In the following example the different periods of the year are determined manually based on the natural history of Ovenbirds.

Create empty column to later fill with numeric values for period - 

```{r}
oven_transitions$period<-rep(NA,dim(oven_transitions)[1])

head(oven_transitions)
```
Define Breeding based on natural history of species.

Ideally this would be done based on the biology (breeding season) and so on.

Here we will define the breeding period as from the time of capture to July 31.

We will define the non-breeding period as the dates between 1 November - 31 March.

*see Hallworth et al. 2015 for details* 

Assign a stationary period to the transition data

0= Migratory Period, 1=Breeding, 2=Non-breeding 
```{r}
names(oven_transitions)
oven_transitions[c(1:102,673:768),4]<-1
oven_transitions[103:287,4]<-0
oven_transitions[288:534,4]<-2
oven_transitions[535:672,4]<-0
```

Generate sun-elevation angles for different periods of the year using Ekstrom-Hill calibration. The Ekstrom-Hill calibrartion generates a sun-elevation angle for all non-zero periods.

```{r warning=FALSE}
HillEkstromCalib(tFirst= oven_transitions[,1],
                 tSecond= oven_transitions[,2],
                 type=oven_transitions[,3],
                 site=oven_transitions[,4],
                 start.angle=c(0,-3), #angle to start  process c(breeding,nonbreeding)
                 plot=TRUE)
```

Define a column to store the sun elevation angles that were just generated.
```{r}
oven_transitions$sun<-rep(NA,dim(oven_transitions)[1])
```

Fill the new column using the sun-elevation angle for the known location (breeding = -2.55) and Ekstrom-Hill calibration for unknown locations (non-breeding = -2.1)

```{r}
names(oven_transitions)
oven_transitions[c(1:102,673:768),5]<-(-2.55)
oven_transitions[103:287,5]<-(0) # Migration values are zero in this example
oven_transitions[288:534,5]<-(-2.1)
oven_transitions[535:672,5]<-(0) # Migration values are zero in this example
```

**Note** - *One could treat migration points differently - for example, the midpoint*
*between breeding and non-breeding sun elevations could be used as a*
*transition period (this would need to be justified in your manuscript)*
*or you could use either the breeding or non-breeding sun angle but also*
*would need to be justified.*  
 

Generate new location data based on newly derived sun-elevation angles 
```{r}
ovenLocationsEHC<-coord(tFirst= oven_transitions[,1],
                        tSecond= oven_transitions[,2],
                        type=oven_transitions[,3], 
                        degElevation=oven_transitions$sun,
                        sites=oven_transitions[,4])
```

#### Plot the new location data
Left = Single sun-elevation angle (-2.55)

Middle = Non-breeding sun-elevation angle determined using Esktrom-Hill calibration (-2.1)

Right = Non-breeding sun-elevation angle determined using in-habitat calibration (-3.4) (not shown)
[Hallworth et al. 2015](https://www.researchgate.net/publication/273131898_Migratory_connectivity_of_a_Neotropical_migratory_songbird_revealed_by_archival_light-level_geolocators) 

```{r include=FALSE, cache=TRUE,cache.path=paste0(getwd(),"/Hallworth_cache/GeoLight/")}
NB_ovenEHC<-data.frame(ovenLocationsEHC[288:534,1],ovenLocationsEHC[288:534,2])
NBwidthEHC<-Hlscv(NB_ovenEHC)
NonBreeding_KDE_EHC<-raster(kde(x=NB_ovenEHC,H=NBwidthEHC))
NB.breaksEHC<-seq(from=0,to=maxValue(NonBreeding_KDE_EHC),(maxValue(NonBreeding_KDE_EHC)/100))
oven_transitions$sunKnown<-rep(NA,dim(oven_transitions)[1])
oven_transitions[c(1:102,673:768),6]<-(-2.55)
oven_transitions[103:287,6]<-(0) # Migration values are zero in this example
oven_transitions[288:534,6]<-(-3.4)
oven_transitions[535:672,6]<-(0) # Migration values are zero in this example
ovenLocationsKnown<-coord(tFirst= oven_transitions[,1],
                        tSecond= oven_transitions[,2],
                        type=oven_transitions[,3], 
                        degElevation=oven_transitions$sunKnown,
                        sites=oven_transitions[,4])
NB_ovenKnown<-data.frame(ovenLocationsKnown[288:534,1],ovenLocationsKnown[288:534,2])
NBwidthKnown<-Hlscv(NB_ovenKnown)
NonBreeding_KDE_Known<-raster(kde(x=NB_ovenKnown,H=NBwidthKnown))
NB.breaksKnown<-seq(from=0,to=maxValue(NonBreeding_KDE_Known),(maxValue(NonBreeding_KDE_Known)/100))
```

```{r echo=FALSE, fig.height=5, fig.width=10}
par(mfrow=c(1,3))
plot(world, ylim=c(-9.22,51.15),xlim=c(-107.7,-63.42))
plot(Breeding_KDE,
     axes=FALSE,
     breaks=Breed.breaks,
     col=colorRampPalette(brewer.pal(9,"Blues"))(100),
     legend=FALSE,add=TRUE)
plot(NonBreeding_KDE,
     axes=FALSE,
     breaks=NB.breaks,
     col=colorRampPalette(brewer.pal(9,"Blues"))(100),
     legend=FALSE,add=TRUE)
plot(world,add=TRUE)

plot(world, ylim=c(-9.22,51.15),xlim=c(-107.7,-63.42))
plot(Breeding_KDE,
     axes=FALSE,
     breaks=Breed.breaks,
     col=colorRampPalette(brewer.pal(9,"Reds"))(100),
     legend=FALSE,add=TRUE)
plot(NonBreeding_KDE_EHC,
     axes=FALSE,
     breaks=NB.breaksEHC,
     col=colorRampPalette(brewer.pal(9,"Reds"))(100),
     legend=FALSE,add=TRUE)
plot(world,add=TRUE)

plot(world, ylim=c(-9.22,51.15),xlim=c(-107.7,-63.42))
plot(Breeding_KDE,
     axes=FALSE,
     breaks=Breed.breaks,
     col=colorRampPalette(brewer.pal(9,"Greens"))(100),
     legend=FALSE,add=TRUE)
plot(NonBreeding_KDE_Known,
     axes=FALSE,
     breaks=NB.breaksKnown,
     col=colorRampPalette(brewer.pal(9,"Greens"))(100),
     legend=FALSE,add=TRUE)
plot(world,add=TRUE)
```

*** 
> #### Exercise Four:
> How could using a single sun-elevation angle throughout the year influence your interpretation of the data?   
> Change the sun-elevation angles to see how the locations change.  
> * what happens to the non-breeding locations?
> * what happens to the breeding locations? 
> * What factors may influence the sun-elevation angle?  
> * Does it make sense to use a single or multiple sun-elevation angles throughout the year?  
> * How could you design a project (locations to deploy geolocators) to get a better idea of how sun-elevation angles change throughout the year?

***
> #### Advanced Exercise:
> *  Here we ran through the entire analysis for the Ovenbird but we have a Wood Thrush example as well.  
> *  Run through the entire analysis to determine where the Wood Thrush spent the non-breeding season.  
***

<img align = "center" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/512px-Git-logo.svg.png" height="150px" width = "150px"/>

