---
title: "Lesson two: Objects"
author: "Brian S. Evans, Ph.D."
output: learnr::tutorial
runtime: shiny_prerendered
theme: yeti
---

<!-- html head --> 

<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" href="css/styles.css">
<!--link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"-->
</head>

```{r setup, include=FALSE}
# Load libraries:

library(learnr)
library(RCurl)
library(lubridate)
library(knitr)
library(kableExtra)
library(tidyverse)

knitr::opts_chunk$set(echo = FALSE)
options(knitr.table.format = "html")

# Objects used:

numberObject <-
  c(1, 1, 2, 3)

numericVector <- 
  numberObject

exampleFactor <- 
  factor(
    c('one', 'one', 'two', 'three')
    )

myMatrix <-
  matrix(
    c(1, 1, 2, 3),
    ncol = 2
  )

myList <-
  list(
    numericVector,
    myMatrix
  )

fibVec <- vector('numeric', length = 12)

fibVec[1:2] <- c(0, 1)

for(i in 3:length(fibVec)){
  fibVec[i] <- 
    fibVec[i-1] + fibVec[i-2]
}

fibMat <-
  fibVec %>%
  matrix(
    ncol = 3, byrow = TRUE)

```
<br>

## Introduction

<img src="images/dsWorkflowOverview.png" 
            title="data science workflow"
            alt = "data science diagram"
            style= "float: right; width: 50%; padding-right: 0px; padding-left: 10px; padding-bottom:  10px"/>
            
<p><b>Re-thinking the structure of data:</b> How we have interacted with data in the past dictates how we structure data mentally. Many of us in science, myself included, have learned to use programs like Microsoft Excel (or iOS' numbers, libreOffice's Calc, Google Sheets, etc.) for viewing and managing data. Through learning and using spreadsheet programs, we tend to format and organize data in ways that are incompatible with environments outside of that system. In other words, there are ways that we interact with data in Excel, especially in regards to how we organize spreadsheets, which do not lend itself well to working with data outside of the spreadsheet environment. Under these conditions, using R (and other programming environments) becomes a frustrating exercise of constantly wrestling with datasets to perform even simple analyses. This process ends up taking most of our computer time.</p>

<p>In addition to increasing our stress level when working with R, the spreadsheet paradigm fails to provide us with fully reproducible data or adequate reporting. Ideally, our target audience should be able to reproduce each step of a data process, starting with the raw data itself.</p>

<p>In this lesson we will work to develop a strong understanding of the containers that hold values. These containers are called <b>objects</b>. Different classes of objects structure values in different ways.</p>
<div class = "row">
<br>
```{r echo = FALSE}
require(knitr)
require(kableExtra)

df <-
  data.frame(
    `Dimensions` = c('1-D', '2-D'),
    `Homogeneous` = c('Atomic vector', 'Matrix'),
    `Heterogeneous` = c('List', 'Data frame')
  )

kable(df, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
</div>

<div class = "row">
<p>For each object type, we'll address:</p>
<ul>
<li>The number of dimensions: One vs. two dimensions</li>
<li>The classes of values within an object:
<ul>
<li><b>Homogeneous</b>: Only one class of values per object</li>
<li><b>Heterogeneous</b>: One or more classes of values per object</li>
</ul>
<li><b>Attributes</b> of the object class: Names and dimensions</li>
<li><b>Indexing</b>: Location within an object</li>
</ul>
</div>

<br>


## Atomic vectors

<p>An <b>atomic vector</b> is a <b>one-dimensional</b> collection of values. Values in an atomic vector are <b>homogeneous</b>. In other words, all values must be of the same class. We've already learned how to create an atomic vector -- this is the type of object that we created using the combine function, `c()`.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i>Create an atomic vector with the numbers 1, 1, 2, and 3 and assign the name `numericVector` to the object.</p>

```{r avec, exercise = TRUE, exercise.lines = 5}
# Create an atomic vector:
```

```{r avec-hint-1}
numericVector <- ...
```

```{r avec-hint-2}
numericVector <- 
  c(...)
```

```{r avec-hint-3}
numericVector <- 
  c(1, 1, 2, 3)
```

<p>To print the output, type the name assigned to the object:</p>

```{r printAvec, exercise = TRUE, exercise.lines = 5}
# View the atomic vector:

```

</div>
<br>

<h3>The structure of atomic vectors</h3>

<p>The structure of an object describes the class of object and the number of values of an object in each dimension. In the previous lesson we used `class()` and `typeof()` to observe object class and type. For atomic vectors, which are one-dimensional we can use `length()` to determine the number of values that make up the object.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i>Determine the class and type of values in the object `numericVector`.</p>

```{r classType_avec, exercise = TRUE, exercise.lines = 5}
# Class and type of numericVector:
```

```{r classType_avec-hint-1}
class(...)

typeof(...)
```

```{r classType_avec-hint-2}
class(numericVector)

typeof(numericVector)
```

<p>Determine the number of values that make up the numericVector.</p>

```{r length_avec, exercise = TRUE, exercise.lines = 5}
# Number of values in numericVector:

```

```{r length_avec-hint-1}
length(...)
```

```{r length_avec-hint-2}
length(numericVector)
```

</div>

<br>
<p>We can view the length and class of an object in one step using the function `str()` (structure).</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i>Use `str()` to determine the class and number of values in the object `numericVector` in one step.</p>

```{r str_avec, exercise = TRUE, exercise.lines = 5}
# str can be used to observe object structure:

```

```{r str_avec-hint-1}
str(...)
```

```{r str_avec-hint-2}
str(numericVector)
```
</div>

<br>
<p>If the object is numeric, integer, or factor, we can view quantitative summary information of an object using the `summary()` function.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i>Use `summary()` to calculate summary statistics for the object `numericVector`.</p>
```{r summary_avec, exercise = TRUE, exercise.lines = 5}
# str can be used to observe object structure:

```

```{r summary_avec-hint-1}
summary(...)
```

```{r summary_avec-hint-2}
str(numericVector)
```
</div>

<br>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> To explore how atomic vectors are homogeneous, observe what happens when the values input into an atomic vector are heterogeneous. Create a vector with the values, 1, 'one', 2, and 3</p>

```{r heteroV, exercise = TRUE, exercise.lines = 5}
# All values in a vector must be of the same class:

```
</ul>
```{r heteroV-hint-1}
c(...)
```


```{r heteroV-hint-2}
c(1, 'one', 2, 3)
```
<br>
<p>Repeat the above and use `class()` to determine the class of the object</p>


```{r heteroV_class, exercise = TRUE, exercise.lines = 5}
# All values in a vector must be of the same class:

```
</ul>
```{r heteroV_class-hint-1}
class(...)
```

```{r heteroV_class-hint-2}
class(
  c(...)
)
```

```{r heteroV_class-hint-3}
class(
  c(1, 'one', 2, 3)
)
```
<br>
<p>Repeat the above and use `str()` to determine the length and class of the object</p>

```{r heteroV_str, exercise = TRUE, exercise.lines = 5}
# All values in a vector must be of the same class:

```
</ul>
```{r heteroV_str-hint-1}
str(...)
```

```{r heteroV_str-hint-2}
str(
  c(...)
)
```

```{r heteroV_str-hint-3}
str(
  c(1, 'one', 2, 3)
)
```
<br>
<p>Repeat the above and use `summary()` to calculate the summary statistics of the object (if possible!)</p>

```{r heteroV_summary, exercise = TRUE, exercise.lines = 5}
# All values in a vector must be of the same class:

```
</ul>
```{r heteroV_summary-hint-1}
summary(...)
```

```{r heteroV_summary-hint-2}
summary(
  c(...)
)
```

```{r heteroV_summary-hint-3}
summary(
  c(1, 'one', 2, 3)
)
```
</div>
<br>

<h3>Attributes of Atomic vectors</h3>

<p>You can determine the attributes of an object using the function `attributes()`. Vectors typically do not have attributes. Some attributes, however, can be added to vectors. For example, we might want to get or add names to a vector. We can both assess and add to the names attribute of a vector using the `names()` function.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Explore the code below, which demonstrates adding names attributes to the values a vector</p>
```{r vectorNames, exercise = TRUE, exercise.lines = 5}
# Adding attributes to a vector:

names(numericVector)

names(numericVector) <- 
  c('orange', 'pear', 'apple', 'grape')

numericVector

attributes(numericVector)
```
</div>

<br>
<h3>Indexing atomic vectors</h3>

<p>Each value in a vector has a both a value and a position, denoted by "[<i>x</i>]". The position and value information for our `numericVector` could be written as:</p>

```{r echo = FALSE}

df <-
  data.frame(
    `Position` = c('[1]','[2]','[3]','[4]'),
    `Value` = c(1, 1, 2, 3)
  )

df <-
  data_frame(
    `[1]` = 1,
    `[2]` = 1,
    `[3]` = 2,
    `[4]` = 3
  )

kable(df, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = 'center')
```

<br>
<p>The brackets above represent an index of a values location. We can refer to this index using the notation `object_name[x]`. This process is method to <b>filter</b> or <b>subset</b> a vector by position. Filtering or querying a data object is the process of reducing the number of values in that object to only those that match a given condition. It may be useful to consider the code snippet `object_name[x]` as `object_name` where (`[`) the position is equal to `x`. For example, we could subset the `numericVector` object to the second value by typing `numericVector[2]`.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Subset the atomic vector `numericVector` to the value at position 3:</p>
```{r numeric3, exercise = TRUE, exercise.lines = 5}
# Subset numericVector to the value associated with position 3:

```

```{r numeric3-hint-1}
numericVector
```

```{r numeric3-hint-2}
numericVector[...]
```

```{r numeric3-hint-3}
numericVector[3]
```
</div>

<br>
<p>The value, `3`, that we indexed above is actually a vector of one value, the number three. We can determine the values at multiple positions by providing a vector of multiple integer positions inside the brackets.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Subset the atomic vector `numericVector` to the values at positions 1, 2, and 3:</p>

```{r numeric123, exercise = TRUE, exercise.lines = 5}
# Use indexing to subset a vector to the first, second, and third positions:

```

```{r numeric123-hint-1}
numericVector[...]
```

```{r numeric123-hint-2}
numericVector[1:3]
```

```{r numeric123-hint-3}
# or:
numericVector[c(1,2,3)]
```
</div>


<br>
<p>In addition to indexing a named vector by position, you can also index a named vector by name, by indexing a vector of names in quotes. For example, we might consider our vector above as:</p>
<br>
```{r echo = FALSE}
df <-
  data_frame(
    `['orange']` = 1,
    `['pear']` = 1,
    `['apple']` = 2,
    `['grape']` = 3
  )

kable(df, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = 'center')
```
<br>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Subset the atomic vector `numericVector` to the position in which the name of the value is "grape":</p>
```{r vectorNames_subset, exercise = TRUE, exercise.lines = 5}
# Indexing a vector by the name of the value:

names(numericVector) <- 
  c('orange', 'pear', 'apple', 'grape')

numericVector[...]
```

```{r vectorNames_subset-hint-1}
names(numericVector) <- 
  c('orange', 'pear', 'apple', 'grape')

numericVector['grape']
```
</div>

<br>
<p>You may also choose to subset the named vector by denoting position using a vector of names.</p>
<br>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Subset the atomic vector `numericVector` to the position in which value is named "orange" or "grape":</p>
```{r vectorNames_subset2, exercise = TRUE, exercise.lines = 5}
# Indexing a vector by the name of the value:

names(numericVector) <- 
  c('orange', 'pear', 'apple', 'grape')

numericVector[...]
```

```{r vectorNames_subset2-hint-1}
names(numericVector) <- 
  c('orange', 'pear', 'apple', 'grape')

numericVector[c(...)]
```

```{r vectorNames_subset2-hint-2}
names(numericVector) <- 
  c('orange', 'pear', 'apple', 'grape')

numericVector[c('orange', 'grape')]
```
</div>

<p>We will be addressing indexing in depth in the next lesson, so be sure you have a thorough understanding of the above!</p>

<hr>

## Matrix objects
<br>
<p>A <b>matrix</b> is a two dimensional object -- an atomic vector that is arranged into rows and columns (see `?matrix`). You can use the function `matrix()` to create a matrix. The first argument to supply to the matrix function is the data that you would like to express as a matrix. You can add arguments specifying the number of rows, `nrow`, or columns, `ncol` to change the shape of the resultant matrix. These arguments accept numeric values.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Convert the atomic vector `c(1, 1, 2, 3)` into a matrix object:</p>
```{r mat, exercise = TRUE, exercise.lines = 5}
# Convert c(1, 1, 2, 3) to a matrix:

c(1, 1, 2, 3)
```

```{r mat-hint-1}
matrix(
  c(1, 1, 2, 3)
)
```

<p>Repeat the above and use the `nrow` or `ncol` arguments to arrange the matrix into an object with two rows and two columns:<p>
```{r mat_ncol, exercise = TRUE, exercise.lines = 5}
# Convert c(1, 1, 2, 3) to a matrix:

matrix(
  c(1, 1, 2, 3)
)
```

```{r mat_ncol-hint-1}
matrix(
  c(1, 1, 2, 3),
  nrow = ...
)

# or ...

matrix(
  c(1, 1, 2, 3),
  ncol = ...
)
```


```{r mat_ncol-hint-2}
matrix(
  c(1, 1, 2, 3),
  nrow = 2
)

# or ...

matrix(
  c(1, 1, 2, 3),
  ncol = 2
)
```
</div>

<br>
<p>Note in the above that the matrix was created by arranging the atomic vector into columns. When you generated the matrix without an `nrow` or `ncol` argument, the data were arranged as a one column matrix, in the order of the values of the vector. Specifying `nrow` or `ncol` split the column, but the order of values remains the same. This order is known as "by column". You can specify that you would like to arrange the values of the atomic vector in the matrix "by row" by adding a `byrow` argument to the matrix function. This argument accepts logical values (TRUE or FALSE).</p> 

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Observe what happens when a matrix is generated with the argument `byrow = TRUE`:</p>
```{r mat_byrow, exercise = TRUE, exercise.lines = 10}
# Convert c(1, 1, 2, 3) to a matrix:

matrix(
  c(1, 1, 2, 3),
  nrow = 2,
  byrow = FALSE
)

matrix(
  c(1, 1, 2, 3),
  nrow = 2,
  byrow = TRUE
)
```
</div>


<br>
<p>When we use the `class()` function, the class of object is returned. The `typeof()` function provides the type of values that make up the object. Like the atomic vectors that matrices <i>secretly</i> are, all values in a matrix must be of the same type of values.</p>


<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Generate a matrix using the values 1, 'one', 2, and 3.</p>
```{r mat_hetero, exercise = TRUE, exercise.lines = 5}
# Convert c(1, 'one', 2, 3) to a matrix:

```

```{r mat_hetero-hint-1}
matrix(...)

```


```{r mat_hetero-hint-2}
matrix(
  c(...)
)

```

```{r mat_hetero-hint-3}
matrix(
  c(1, 'one', 2, 3)
)

```

<p>Use `class` to determine the class of object that was generated</p>

```{r mat_hetero_class, exercise = TRUE, exercise.lines = 5}
# What is the class of the above object?

```

```{r mat_hetero_class-hint-1}
class(...)
```

```{r mat_hetero_class-hint-2}
class(
  matrix(...)
)
```

```{r mat_hetero_class-hint-3}
class(
  matrix(
    c(...)
  )
)
```

```{r mat_hetero_class-hint-4}
class(
  matrix(
    c(1, 'one', 2, 3)
  )
)
```

<p>Use `typeof()` to determine the type of values that make up the matrix</p>

```{r mat_hetero_typeof, exercise = TRUE, exercise.lines = 5}
# What type of values make up the above matrix?

```

```{r mat_hetero_typeof-hint-1}
typeof(...)
```

```{r mat_hetero_typeof-hint-2}
typeof(
  matrix(...)
)
```

```{r mat_hetero_typeof-hint-3}
typeof(
  matrix(
    c(...)
  )
)
```

```{r mat_hetero_typeof-hint-4}
typeof(
  matrix(
    c(1, 'one', 2, 3)
  )
)
```
</div>


<br>
<p>Matrices have one attribute (`?attributes`) by default -- the dimensions of the matrix. Additional attributes, such as row and column names, can be added using the `rowNames()` and `colNames()` functions, respectively.<p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Generate a two-column matrix using the values 1, 1, 2, 3, 5, 8, 13, and 21 and assign the name `myMatrix` to the object.</p>
```{r myMat, exercise = TRUE, exercise.lines = 5}
# Convert c(1, 1, 2, 3) to a matrix and assign a name:

```

```{r myMat-hint-1}
myMatrix <- ...

```


```{r myMat-hint-2}
myMatrix <- 
  matrix(...)
```

```{r myMat-hint-3}
myMatrix <-
  matrix(
    c(...),
    ncol = ...
  )
```

```{r myMat-hint-4}
myMatrix <-
  matrix(
    c(1, 1, 2, 3, 5, 8, 13, 21),
    ncol = 2
  )
```

<p>No output? Type the name (and run the line of code) to see the object</p>

```{r myMat_print, exercise = TRUE, exercise.lines = 2}

```

```{r myMat_print-hint-1}
myMatrix
```

<p>Determine the attributes of the object `myMatrix`:</p>
```{r myMat_attributes, exercise = TRUE, exercise.lines = 5}
# Attributes of myMatrix:


```

```{r myMat_attributes-hint-1}
attributes(...)
```

```{r myMat_attributes-hint-2}
attributes(myMatrix)
```

<p>Add the column names "hello" and "world" to `myMatrix` and view the attributes of the resultant object:</p>
```{r myMat_colNames, exercise = TRUE, exercise.lines = 5}
# Add column names to myMatrix:

colnames(myMatrix) <- ...
```

```{r myMat_colNames-hint-1}
colnames(myMatrix) <- 
  c(...)
```


```{r myMat_colNames-hint-2}
colnames(myMatrix) <- 
  c('hello', 'world')

attributes(...)
```

```{r myMat_colNames-hint-3}
colnames(myMatrix) <- 
  c('hello', 'world')

attributes(myMatrix)
```
</div>


<br>
<h3>Matrix objects: Indexing</h3>
<br>
<p>Values in a matrix have a row (x) and column (y) position, denoted by "[<i>x</i>, <i>y</i>]". It may be useful for you to think of a value's position (also known as "address") as "[<i>row</i>, <i>column</i>]".</p>

<table style = "font-size: 1.1em; vertical-align: middle;">
<tr>
  <th style = "text-align: center; font-weight: normal;"></th>
  <th style = "text-align: center; font-weight: normal;">[ ,1]</th>
  <th style = "text-align: center; font-weight: normal;">[ ,2]</th>
</tr>
<tr>
  <td style = "text-align: center;">[1, ]</td>
  <td style = "text-align: center;">1</td>
  <td style = "text-align: center;">2</td>
</tr>
<tr>
  <td style = "text-align: center;">[2, ]</td>
  <td style = "text-align: center;">1</td>
  <td style = "text-align: center;">3</td>
</tr>
</table>
<br>

<p>Just as you would specify `vectorName[x]` to extract the value from the object `vectorName` at position `x`, you can use this notation to extract values from a matrix. To do so, you need to specify the `x` and `y` address using: `matrixName[x, y]` -- this will return all values of the object `matrixName` where the row number is equal to x and the column number is equal to y.</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> What is the value of `myMatrix` at row 1, column 2?</p>  

```{r myMat_index, exercise = TRUE, exercise.lines = 5}
# Determine the value of myMatrix at row 1, column 2:

myMatrix

```

```{r myMat_index-hint-1}
myMatrix[..., ...]
```

```{r myMat_index-hint-2}
myMatrix[1, ...]
```

```{r myMat_index-hint-3}
myMatrix[1, 2]
```
</div>

<br>
<p>As with atomic vectors, you can specify a range or subset of values by supplying a vector of numbers for either the `x` or `y` position. You can subset a matrix dimension by name by using the column (or row) name instead of the numeric position. You can specify all values for a row or column by leaving the `x` or `y` position blank (e.g., `[x,]` or `[,y]`).</p> 

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Subset the object `myMatrix` using the following criteria:</p>

<ul>
<li>All values in column 1:</li>
```{r myMat_index1, exercise = TRUE, exercise.lines = 2}

myMatrix[..., ...]

```

```{r myMat_index1-hint-1}
myMatrix[..., 1]
```

```{r myMat_index1-hint-2}
myMatrix[, 1]
```

<li>All values in row 1:</li>
```{r myMat_index2, exercise = TRUE, exercise.lines = 2}

myMatrix[..., ...]

```

```{r myMat_index2-hint-1}
myMatrix[1, ...]
```

```{r myMat_index2-hint-2}
myMatrix[1, ]
```

<li>The first <b>through</b> third values in column 2:</li>

```{r myMat_index3, exercise = TRUE, exercise.lines = 2}

myMatrix[..., ...]

```

```{r myMat_index3-hint-1}
myMatrix[..., 2]
```

```{r myMat_index3-hint-2}
myMatrix[1:3, 2]
```

<li>The first <b>and</b> third values in column 2:</li>
```{r myMat_index4, exercise = TRUE, exercise.lines = 2}

myMatrix[..., ...]

```

```{r myMat_index4-hint-1}
myMatrix[c(1, 3), ...]
```

```{r myMat_index4-hint-2}
myMatrix[c(1, 3), 2]
```

<li>All values in the column named "world":</li>
```{r myMat_index5, exercise = TRUE, exercise.lines = 2}

myMatrix[..., ...]

```

```{r myMat_index5-hint-1}
myMatrix[, ...]
```

```{r myMat_index5-hint-2}
myMatrix[, 'world']
```

<li>The first <b>and</b> third values in the column named "world":</li>
```{r myMat_index6, exercise = TRUE, exercise.lines = 2}

myMatrix[..., ...]

```

```{r myMat_index6-hint-1}
myMatrix[, 'world']
```

```{r myMat_index6-hint-2}
myMatrix[c(1, 3), 'world']
```

</div>

<hr>

## List objects
<br>
<p>A <b>list</b> is a one dimensional object constructed by combining ANY objects with ANY dimensionality. Because of their flexibility, lists can be very powerful (and occasionally messy and/or dangerous!). A list is created using the `list()` function, the arguments of which are the items contained within the list.</p>
<br>
<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Explore the following to observe the structure of lists:</p>

```{r list, exercise = TRUE, exercise.lines = 5}
# Homogeneous list of values:

list(1, 1, 2)

# Heterogeneous list of values:

list(1, 'one', 2)

# List of objects:

list(numericVector, myMatrix)

myList <-
  list(numericVector, myMatrix)

myList
```
</div>
<br>

<p>List items can be named. To do so, you may name a pre-existing list using the convention `names(listName) <- c(namesVector)`. You may also specify the names when the list is created (e.g., `list(hello = 1, world = 2)`).</p>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Explore the following to observe the naming of list items:</p>
```{r list_names, exercise = TRUE, exercise.lines = 5}
# Specify list names when the list is constructed:

list(apple = 1, pear = 2)

# Specify the names of a pre-existing list:

names(myList) <-
  c('hello', 'world')
```
</div>

<br>

<h3>List objects: Indexing</h3>
<br>
<p>List position is denoted by [[<i>x</i>]].</p>
<br>

<div class = "row">
<p>[[1]]</p>
<table style = "font-size: 1em; vertical-align: middle; float: left; padding: 10px">
<tr>
<th style = "text-align: center; font-weight: normal;">[1]</th>
<th style = "text-align: center; font-weight: normal;">[2]</th>
<th style = "text-align: center; font-weight: normal;">[3]</th>
<th style = "text-align: center; font-weight: normal;">[4]</th>
</tr>
<tr>
<td style = "text-align: center;">1</td>
<td style = "text-align: center;">1</td>
<td style = "text-align: center;">2</td>
<td style = "text-align: center;">3</td>
</tr>
</table>
<br>
</div>

<div class = "row">
<p>[[2]]</p>
<table style = "font-size: 1.1em; vertical-align: middle;">
<tr>
<th style = "text-align: center; font-weight: normal;"></th>
<th style = "text-align: center; font-weight: normal;">[ ,1]</th>
<th style = "text-align: center; font-weight: normal;">[ ,2]</th>
</tr>
<tr>
<td style = "text-align: center;">[1, ]</td>
<td style = "text-align: center;">1</td>
<td style = "text-align: center;">2</td>
</tr>
<tr>
<td style = "text-align: center;">[2, ]</td>
<td style = "text-align: center;">1</td>
<td style = "text-align: center;">3</td>
</tr>
</table>
<br>
</div>

<div class = "row">
<p>[[3]]</p>
<table style = "font-size: 1.1em; vertical-align: middle;">
<tr>
<th style = "text-align: center; font-weight: normal;"></th>
<th style = "text-align: center; font-weight: normal;">[ ,1]</th>
<th style = "text-align: center; font-weight: normal;">[ ,2]</th>
</tr>
<tr>
<td style = "text-align: center;">[1, ]</td>
<td style = "text-align: center;">"1"</td>
<td style = "text-align: center;">"2"</td>
</tr>
<tr>
<td style = "text-align: center;">[2, ]</td>
<td style = "text-align: center;">"one"</td>
<td style = "text-align: center;">"3"</td>
</tr>
</table>
</div>
<br>


```{r eval = FALSE}
# List indexing:

exampleList

exampleList[[2]]

exampleList[[2]] == m

m[2,2]

exampleList[[2]][2,2]
```

<br>
<h3>Attributes of lists</h3>
<br>
<div style = "text-align: left;">
<p>Typical attributes we are interested in of lists include:</p>
<ul>
<li><b>Class</b>: What type of values?
<li><b>Length</b>: How many values?
</ul>
</div>
<br>

```{r eval = FALSE}
# Attributes of a list:

class(exampleList)

length(exampleList)

str(exampleList)

# Attributes of list items:

class(exampleList[[1]])

length(exampleList[[1]])

```

<br>
<p>Attributes, such as names, can be added to lists:</p>
<br>

```{r eval = FALSE}
# Adding attributes to a list:

exampleList

names(exampleList)

names(exampleList) <- c('numericVector', 'm', 'messyMatrix')

attributes(exampleList)
```
<br>
<p>If named have been provided, lists can be indexed by their names attribute using matrix notation or the `$` operator.</p>
<br>

```{r eval = FALSE}
# Lists can be indexed by name using the notation:

exampleList[[3]]

exampleList[['messyMatrix']]

exampleList$messyMatrix

```
<hr>
## Data frames
<br>
<p>A <b>data frame</b> is a two dimensional object constructed by combining vectors.</p>
<br>

```{r eval = FALSE}
# Generate a data frame:

df <- data.frame(a = c(1, 1), b =  c(2, 3))

df
```
<br>
<p>A matrix may also be converted to a data frame using the `as.data.frame` function.</p>
<br>

```{r eval = FALSE}
# Generate a data frame from a matrix:

as.data.frame(m)

```

<br>

<br>
<p>The vectors that are contained in a data frame may be of different classes.</p>
<br>

```{r eval = FALSE}
# Generate a data frame of different vector classes:

data.frame(a = c('one', 'one'), b =  c(2, 3))

```
<br>

<p>But individual vectors are still coerced into the same class!</p>
<br>

```{r eval = FALSE}
# Attempt to generate a data frame with heterogeneous vectors:

messyDf <- data.frame(a = c(1, 'one'), b =  c(2, 3))

messyDf

```

<br>
<h3>Indexing data frames</h3>
<br>
<p>Values in a data frame have a row (x) and column (y) position, denoted by "[<i>x</i>, <i>y</i>]"</p>

<br>
<table style = "font-size: 1.1em; vertical-align: middle;">
<tr>
  <th style = "text-align: center; font-weight: normal;"></th>
  <th style = "text-align: center; font-weight: normal;">[ ,1]</th>
  <th style = "text-align: center; font-weight: normal;">[ ,2]</th>
</tr>
<tr>
  <td style = "text-align: center;">[1, ]</td>
  <td style = "text-align: center;">1</td>
  <td style = "text-align: center;">1</td>
</tr>
<tr>
  <td style = "text-align: center;">[2, ]</td>
  <td style = "text-align: center;">2</td>
  <td style = "text-align: center;">3</td>
</tr>
</table>
<br>
<br>

```{r eval = FALSE}
# Index by row (x) and column (y) position [x,y]:

df[1,1]

df[2,2]

df[1:2,2]

df[1,]

df[,2]

```
<br>
<br>
<h3>Attributes of data frames</h3>
<br>
<p>There are a number of attributes that can be observed for a given data frame:</p>

```{r eval = FALSE}
# View data frame attributes:

str(df)

class(df)

length(df)

dim(df)

summary(df)
```
<br>
<p>Always check attributes prior to working with data frame!</p>
<br>

```{r eval = FALSE}
# View attributes of the messy dataframe:

str(messyDf)

dfStrings <- data.frame(
  a = c(1, 'one'), 
  b =  c(2, 3),
  stringsAsFactors = FALSE
  )

str(dfStrings)

```

<br>
<p>Name attributes are automatically set when a data frame is created. Failing to set this attribute leads to bad names:</p>
<br>

```{r eval = FALSE}
# Set and unset names:

data.frame(a = c(1, 1), b =  c(2, 3))

data.frame(c(1, 1),c(2, 3))

```

<br>
<p>Similar to other objects, the names attribute can also be set manually after an object is created:</p>
<br>

```{r eval = FALSE}
# View data frame attributes:

exampleDf <- data.frame(c(1, 1),c(2, 3))

names(exampleDf) <- c('hello', 'world')

exampleDf

```

<br>
<p>Data frames can be indexed by their names attribute using matrix notation or the `$` operator.</p>
<br>

```{r eval = FALSE}
# View data frame attributes:

exampleDf['hello']


exampleDf$hello

```
<br>
## Tibble data frames!</h2>
<br>
<p>A <b>tibble</b> is a special type of data frame provided by the package tidyverse.</p>
<br>

```{r eval = FALSE}
# Read tidyverse package(s):

library(tidyverse)

# Generate a tibble data frame:

tibbleDf <- data_frame(a = c(1, 'one'), b =  c(2, 3))

tibbleDf
```
<br>

<p>Base R data frames can also be converted to a tibble.</p>
<br>

```{r eval = FALSE}
# Convert a data frame to a tbl:

tbl_df(messyDf)

tbl_df(data.frame(a = c(1, 'one'), b =  c(2, 3)))

```

<br>

<p>How do tibbles differ from Base R data frames?</p>
<br>

```{r eval = FALSE}
# Compare tibble and base R data frame:

data.frame(a = c(1, 'one'), b =  c(2, 3))

data_frame(a = c(1, 'one'), b =  c(2, 3))

# Load data and compare between a data frame and a tibble:
# Note: the "data" function loads example datasets

data(iris)

iris

tbl_df(iris)
```

<br>
<hr>

<b>End of lesson 2</b>
<img style="float: right; margin: 0px 0px 15px 15px;" src="nzpLogoSideways2.png" width="300" />
