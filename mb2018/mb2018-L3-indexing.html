<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Brian S. Evans, Ph.D." />


<meta name="progressive" content="false" />
<meta name="allow-skip" content="false" />

<title>Lesson three: Indexing</title>


<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>



<div class="pageContent band">
<div class="bandContent page">

<div class="topics">

<!-- html head -->
<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> <link rel="stylesheet" type="text/css" href="css/styles.css"> <!--link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"-->
</head>
<div id="section-introduction" class="section level2">
<h2>Introduction</h2>
<p>
In this lesson we will be exploring how to query data using what is often called “indexing” or “matrix notation”. We will learn a <b>much easier</b> way to query data by the end of this workshop. I start by teaching this method of querying because it is helpful in understanding how R objects work, gives a glimpse of what is happening under the hood when using other querying techniques, and still used for some advanced querying techniques.
</p>
</div>
<div id="section-review-logical-values" class="section level2">
<h2>Review: logical values</h2>
<br>
<p>
Recall that logical values can be obtained by evaluating objects with <b>logical operators</b>. For example, the logical operator <code>==</code> tests whether a value is equal to another value.
</p>
<p><br></p>
<div class="reviewDiv">
<p>
<i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Use the logical operator <code>==</code> to test whether the each set of values is equivalent (<span class="math inline">\(\equiv\)</span>).
</p>
<p>
<span class="math inline">\(21 \equiv 34\)</span>
</p>
<pre class="r"><code>21 == 34</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>
<span class="math inline">\(21 \equiv 21\)</span>
</p>
<pre class="r"><code>21 == 21</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>
<span class="math inline">\(21 \equiv 34 - 13\)</span>
</p>
<pre class="r"><code>21 == 34 - 13</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>
<span class="math inline">\(34 \equiv 21 + 13\)</span>
</p>
<pre class="r"><code>34 == 21 + 13</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>
<span class="math inline">\(21 \equiv 13 - 34\)</span>
</p>
<pre class="r"><code>21 == 13 - 34</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>
<span class="math inline">\((21 \equiv 34) + (34 \equiv 21 + 13)\)</span>
</p>
<pre class="r"><code>(31 == 34) + (34 == 21 + 13)</code></pre>
<pre><code>## [1] 1</code></pre>
</div>
<p><br></p>
</div>
<div id="section-using-logic-with-objects" class="section level2">
<h2>Using logic with objects</h2>
<br>
<p>
We can run a logic test on objects with more than one value. In the following examples, R tests whether each value in the objects below are equal to 3 and returns logical values in the dimensions of the object.
</p>
<p><br></p>
<pre class="r"><code># Generate and evaluate whether values in vector v are equal to 3:

v &lt;- c(1,1,2,3,5,8)

v

v == 3

# Generate and evaluate whether values in matrix m are equal to 3:

m &lt;- matrix(v, ncol = 2)

m

m == 3

# Generate and evaluate whether values in data frame df are equal to 3:

df &lt;- as.data.frame(m)

df

df == 3</code></pre>
<p><br></p>
</div>
<div id="section-the-logical-operators" class="section level2">
<h2>The logical operators</h2>
<h3>
Comparing values
</h3>
<br>
<p>
The table below provides a set of the logical operators that are most commonly used to compare values. In each of the table items we are evaluating some object (or value) x relative to some object y.
</p>
<p><br></p>
<table class="table table-striped table-hover" style="font-size: 14px; width: auto !important; ">
<thead>
<tr>
<th style="text-align:left;">
Operator
</th>
<th style="text-align:left;">
Usage
</th>
<th style="text-align:left;">
Meaning
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
==
</td>
<td style="text-align:left;">
x == y
</td>
<td style="text-align:left;">
x is equal to y
</td>
</tr>
<tr>
<td style="text-align:left;">
!=
</td>
<td style="text-align:left;">
x != y
</td>
<td style="text-align:left;">
x is NOT equal to y
</td>
</tr>
<tr>
<td style="text-align:left;">
|
</td>
<td style="text-align:left;">
x | y
</td>
<td style="text-align:left;">
x OR y
</td>
</tr>
<tr>
<td style="text-align:left;">
&amp;
</td>
<td style="text-align:left;">
x &amp; y
</td>
<td style="text-align:left;">
x AND y
</td>
</tr>
<tr>
<td style="text-align:left;">
&lt;
</td>
<td style="text-align:left;">
x %in% yz
</td>
<td style="text-align:left;">
x is in the vector c(y,z)
</td>
</tr>
<tr>
<td style="text-align:left;">
&lt;=
</td>
<td style="text-align:left;">
x &lt; y
</td>
<td style="text-align:left;">
x is less than y
</td>
</tr>
<tr>
<td style="text-align:left;">
%in%
</td>
<td style="text-align:left;">
x &lt;= y
</td>
<td style="text-align:left;">
x is less than or equal to y
</td>
</tr>
<tr>
<td style="text-align:left;">
&gt;
</td>
<td style="text-align:left;">
x &gt; y
</td>
<td style="text-align:left;">
x is greater than y
</td>
</tr>
<tr>
<td style="text-align:left;">
&gt;=
</td>
<td style="text-align:left;">
x &gt;= y
</td>
<td style="text-align:left;">
x is greater than or equal to y
</td>
</tr>
</tbody>
</table>
<p>
Each of the logical operators above can be applied in the same way that we have applied <code>==</code> thus far. Try out the code below, then conduct your own logical tests to explore their application further.
</p>
<p><br></p>
<pre class="r"><code># Explore logical operators with vector v:

v

v != 3

!(v == 3)

v &lt; 3

v &lt;= 3

v &gt; 3

v &gt;= 3</code></pre>
<p><br></p>
<p>
Repeat the above with your matrix, <code>m</code>, and data frame, <code>df</code>.
</p>
<p><br></p>
<h3>
Comparing sets
</h3>
<p><br></p>
<p>
We are often interested in comparing sets of values with one another. Using the code above, we may be interested in testing whether values <code>1</code> and <code>3</code> appear in vector <code>v</code>. To do so, we use the operator <code>%in%</code>, which tests the logic statement “is in”.
</p>
<p><br></p>
<pre class="r"><code># Test whether values in v match values 1 or 3:

v %in% c(1,3)</code></pre>
<p><br></p>
<p>
The NOT statement, <code>!x</code>, wasn’t very useful before. In combination with <code>%in%</code>, it becomes a powerful tool to examine sets.
</p>
<pre class="r"><code># Test whether values in v match values 1 or 3:

!(v %in% c(1,3))</code></pre>
<br>
<p>
You can also compare sets with <i>and/or</i> statements, represented in R by <code>&amp;</code> and <code>|</code>.
</p>
<p><br></p>
<pre class="r"><code># Test whether values in v match values 1 OR 3:

v == 1 | v ==3

# Test whether values in v match values 1 AND 3:

v == 1 &amp; v == 3</code></pre>
<br>
<p>
The first statement above, OR, is equivalent to our previous <code>v %in% c(1,3)</code>. The latter, AND, is not very useful in this case, because none of the values can be both 1 and 3 at the same time.
</p>
<p><br></p>
<p>
The AND operator becomes very useful when querying across multiple conditions. For example, if we wanted to test whether a value was less than 5 and not equal to 2, we would write this out as:
</p>
<p><br></p>
<pre class="r"><code># Test whether values in v are less than 5 and not equal to 2:

v &lt; 5 &amp; v != 2</code></pre>
<br>
<p>
Logic can get pretty hairy fairly quickly with AND/OR statements. It’s good to have a sense of how to tackle more complex statements using these operators. Have a look at the code below and be sure you understand how it is evaluated.
</p>
<p></br></p>
<pre class="r"><code># Test whether values in v are less than 5 and not equal to 2 OR equal to eight:

v &lt; 5 &amp; v != 2 | v == 8</code></pre>
<p><br></p>
</div>
<div id="section-indexing-and-logic" class="section level2">
<h2>Indexing and logic</h2>
<h3>
Querying vectors
</h3>
<br>
<p>
Recall that the position of value <code>x</code> in vector <code>v</code> would be notated as <code>v[x]</code> and that we can use this information to index vector <code>v</code> as follows:
</p>
<p><br></p>
<pre class="r"><code># Use indexing to subset a vector:

v[3]

v[3:4]

v[c(1,3)]</code></pre>
<br>
<p>
In indexing the vector with <code>v[3]</code> above, you essentially instructed R to evaluate and return the statement “vector <code>v</code> where position v<sub>x</sub> is equal to 3”. R returned all of the values from vector <code>v</code> for which this statement was <code>TRUE</code>. In other words, you conducted a query of vector <code>v</code> by <b>position</b>.
</p>
<p><br></p>
<p>
You may also query values by <b>condition</b>, using logic, in the same manner as above. For example, you may want R to evaluate the statement “vector <code>v</code> where value v<sub>x</sub> is greater than two”:
</p>
<p><br></p>
<pre class="r"><code># Use logic to subset a vector:

v

v &gt; 2

v[v &gt; 2]</code></pre>
<br>
<p>
Notice in the above that the line <code>v &gt; 2</code> returned logical values of <code>v</code> associated with that test. The next line of code, <code>v[v &gt; 2]</code> returned values from <code>v</code> that met this condition.
</p>
<p><br></p>
<p>
Why does this work? Let’s take a quick look under the hood. The function <code>which</code> provides the index location of a logical statement. Using the <code>v &gt; 2</code> query above, we can see that:
</p>
<p><br></p>
<pre class="r"><code># At which indices does our logical statement evaluate to TRUE?

v

v &gt; 2

which(v &gt; 2)

v[4:6]

v[v &gt; 2]</code></pre>
<br>
<p>
All of the various logical statements can be applied in the same manner. Please take a moment to query vector <code>v</code> based on the following conditions:
</p>
<ul>
<li>
Values greater than or equal to 3
</li>
<li>
Values that do not equal 2
</li>
<li>
Values that equal 2
</li>
<li>
Values that are greater than or equal to 3 but do not equal 5
</li>
<li>
Values that are 3 or 5
</li>
</ul>
<p><br></p>
<h3>
Querying matrices
</h3>
<br>
<p>
Recall that the position of value <code>x,y</code> (row, column) in a matrix, <code>m</code>, can be notated as <code>m[x,y]</code>. We can use this information to index matrix <code>m</code> as follows:
</p>
<p><br></p>
<pre class="r"><code># Index by matrix m by row (x) and column (y) position [x,y]:

m[1,1]

m[2,2]

m[2, ]

m[ ,2]

m[1:2,2]</code></pre>
<br>
<p>
Working with what is often called “matrix notation” to query objects can be a bit tricky to wrap your head around at first. Let’s start by evaluating <code>m[,]</code>, which returns all of the rows and columns of matrix <code>m</code>:
</p>
<p><br></p>
<pre class="r"><code># All rows and columns of m:

m[,]</code></pre>
<br>
<p>
The statement <code>m[,1]</code> subsets m to all of the rows of the first column. As above, we are evaluating “matrix <code>m</code> where position m<sub>y</sub> is equal to 1”.
</p>
<p><br></p>
<pre class="r"><code># A vector of values associated with the first column of matrix m:

m[,1]</code></pre>
<br>
<p>
We can evaluate vector <code>m[,1]</code> using logic. For example, let’s test <code>m[,1]</code> to determine whether each value is greater than 1:
</p>
<p><br></p>
<pre class="r"><code># Logical test of whether the first column of m is greater than 1:

m[,1] &gt; 1</code></pre>
<br>
<p>
We see that this statement only evaluates as TRUE at one position in the vector. Let’s use <code>which</code>, as above, to determine the index associated with this position:
</p>
<p><br></p>
<pre class="r"><code># At which indices does our logical statement evaluate to TRUE?

which(m[,1] &gt; 1)</code></pre>
<br>
<p>
Because our <code>which</code> statement evaluates to 3, the following queries are equivalent:
</p>
<p><br></p>
<pre class="r"><code># Query m by index and logical statement:

m[3, ]

m[m[,1] &gt; 1, ]</code></pre>
<br>
<p>
Querying using “matrix notation” tends to be hard to read because of the ways that columns have to be specified. For example a query of column two, in which the first column is less than two and the second column is less than 5 would be written as:
</p>
<p><br></p>
<pre class="r"><code># Querying matrix by column 1 less than 2 and column 2 less than 5

which(m[,1] &lt; 2 &amp;  m[,2] &lt; 5)

m[m[,1] &lt; 2 &amp;  m[,2] &lt; 5 , ]</code></pre>
<p><br></p>
<h3>
Querying data frames
</h3>
<br>
<p>
Recall that the position of value <code>x,y</code> (row, column) in a data frame, <code>df</code>, can be notated as <code>df[x,y]</code>. We can use this information to index data frame <code>df</code> as follows:
</p>
<p><br></p>
<pre class="r"><code># Index by matrix m by row (x) and column (y) position [x,y]:

df[1,1]

df[2,2]

df[2, ]

df[ ,2]

df[1:2,2]</code></pre>
<br>
<p>
As you might expect, querying data frames using “matrix notation” is exactly the same as querying matrices. Recall, however, that data frames has a “names” slot built in:
</p>
<p><br></p>
<pre class="r"><code># Attributes of object df:

attributes(df)</code></pre>
<br>
<p>
These names can be set and reset as needed:
</p>
<p><br></p>
<pre class="r"><code># Reset names of object df:

names(df) &lt;- c(&#39;hello&#39;, &#39;world&#39;)

df

attributes(df)</code></pre>
<br>
<p>
Recall that the component vectors in a data frame (i.e., columns – in this case <code>c(1,1,2)</code> and <code>c(3,5,8)</code>) can be accessed by name using the <code>$</code> notation:
</p>
<p><br></p>
<pre class="r"><code># Data frame indexing by position ...

df[,1]

df[,2]

# ... is equivalent to:

df$hello

df$world</code></pre>
<br>
<p>
The above is very useful for querying data frames, because the <code>$</code> notation is much easier to read than “matrix notation”. For example:
</p>
<p><br></p>
<pre class="r"><code># Querying data frames using &quot;matrix notation&quot; ...

df[,1] &gt; 1

which(df[,1] &gt; 1)

df[df[,1] &gt; 1,]

# ... is equivalent to using column names:

df$hello &gt; 1

which(df$hello &gt; 1)

df[df$hello &gt; 1,]</code></pre>
<br>
<p>
In the matrix section, we queried matrix <code>m</code> such that values of column one are less than 2 and values of column two are less than 5. Repeat this query on data frame <code>df</code> using “matrix notation” and the column names of <code>df</code>.
</p>
<p><br></p>
</div>
<div id="section-working-with-strings" class="section level2">
<h2>Working with strings</h2>
<br> <br>
<p>
Strings are notoriously difficult to work with when cleaning data. Luckily the tidyverse libraries contain the package “stringr” that simplifies the process of working with strings. We won’t dive too deeply into the string realm here, but it is important to have some idea of how they work.
</p>
<p><br></p>
<br>
<p>
We’ll start by loading the tidyverse and an example dataset, “fruit”.
</p>
<p><br></p>
<pre class="r"><code>library(tidyverse)

fruit</code></pre>
<br>
<p>
Note that <code>fruit</code> is simply a vector of fruit names. Strings can be indexed like any other value:
</p>
<p><br></p>
<pre class="r"><code># Query the first five fruits by index:

fruit[1:5]</code></pre>
<br>
<p>
<p>Strings have many different characteristics that can be used for querying. We’ve already explored the simplest of them, <code>is equal to</code>. Let’s see how this works:</p>
<pre class="r"><code># Let&#39;s look at our vector of fruit again:

fruit

# If there are duplicate entries (there are not), you can use &quot;unique&quot;:

unique(fruit)

# There is just one apple!

fruit == &#39;apple&#39;

# Which position in the fruit vector is apple?

which(fruit == &#39;apple&#39;)

# Subsetting to fruits named &quot;apple&quot; by position ...

fruit[1]

# ... is equivalent to:

fruit[which(fruit == &#39;apple&#39;)]

# ... and is also equivalent to subsetting by condition:

fruit[fruit == &#39;apple&#39;]</code></pre>
<br>
<p>
You can use the function <code>str_sub</code> to extract characters from strings by their position within the string. It takes as arguments the string being evaluated, the start point of the string, and the end point. Let’s take a moment to explore how this function works:
</p>
<p><br></p>
<pre class="r"><code># Using str_sub, generate an example phrase: 

examplePhrase &lt;- &#39;hello world&#39;

examplePhrase

# Subset to just &quot;hello&quot;:

str_sub(examplePhrase, start = 1, end = 5)

# Subset to just &quot;world&quot;:

str_sub(examplePhrase, start = 7, end = 12)

# You actually don&#39;t have to specify the end point here:

str_sub(examplePhrase, start = 7)

# You can also count from the end:

str_sub(examplePhrase, start = -5)</code></pre>
<br>
<p>
The function <code>str_sub</code> can be used to query a vector of strings. For example, perhaps we wanted to query fruits, subsetting to those that start with the letter “a”:
</p>
<p><br></p>
<pre class="r"><code># str_sub can be used to extract the first letter of each value:

fruit

str_sub(fruit, start = 1, end = 1)

# Which fruits start with the letter &quot;a&quot;?

str_sub(fruit, start = 1, end = 1) == &#39;a&#39;

which(str_sub(fruit, start = 1, end = 1) == &#39;a&#39;)

# Subsetting to fruits with 7 characters by index ...

fruit[1:3]

# ... is equivalent to ...

fruit[which(str_sub(fruit, start = 1, end = 1) == &#39;a&#39;)]

# ... and is also equivalent to subsetting by condition:

fruit[str_sub(fruit, start = 1, end = 1) == &#39;a&#39;]</code></pre>
<br>
<p>
We can also query by the number of characters (i.e., symbols, numbers, or letters) in the string. For example, perhaps we’re not interested in “apple” but rather any fruit that has five letters:
</p>
<p><br></p>
<pre class="r"><code># str_count can be used to determine the number of letters or symbols in a string:

fruit

str_count(fruit)

# Which fruits have exactly 5 letters?

str_count(fruit) == 5

which(str_count(fruit) == 5)

# Subsetting to fruits with 5 characters by index ...

fruit[c(1,34,36,44,49,53,58)]

# ... is equivalent to ...

fruit[which(str_count(fruit) == 5)]

# ... and is also equivalent to subsetting by condition:

fruit[str_count(fruit) == 5]</code></pre>
<br>
<p>
Probably the most useful function for querying strings is <code>str_detect</code>. This function is a logical test of whether a provided pattern is present in a target value. For example, we might explore the example phrase “hello world” as such:
</p>
<p><br></p>
<pre class="r"><code># Detecting a pattern within a string:

examplePhrase

str_detect(examplePhrase, pattern = &#39;hello&#39;)

str_detect(examplePhrase, pattern = &#39;ello&#39;)

str_detect(examplePhrase, pattern = &#39;lo wo&#39;)

str_detect(examplePhrase, pattern = &#39;world&#39;)

str_detect(examplePhrase, pattern = &quot;foo&quot;)

str_detect(examplePhrase, pattern = &#39;helloworld&#39;)</code></pre>
<br>
<p>
Let’s use <code>str_detect</code> to subset the <code>fruit</code> vector to only fruits that contain the word “apple”:
</p>
<p><br></p>
<pre class="r"><code># str_detect can be used to test whether a pattern is present in a string:

fruit

# Which fruits contain the pattern &quot;apple&quot;?

str_detect(fruit, &#39;apple&#39;)

which(str_detect(fruit, &#39;apple&#39;))

# Subsetting to fruits with the pattern &quot;apple&quot; by index ...

fruit[c(1,62)]

# ... is equivalent to ...

fruit[which(str_detect(fruit, &#39;apple&#39;))]

# ... and is also equivalent to subsetting by condition:

fruit[str_detect(fruit, &#39;apple&#39;)]</code></pre>
<p><br></p>
</div>
<div id="section-summarizing-and-queries" class="section level2">
<h2>Summarizing and queries</h2>
<br>
<p>
Querying with indexing and logic can be a great way to summarize your data. Let’s generate a fake data frame and explore the <code>min</code> (minimum value in a set) and <code>max</code> (maximum value in a set) summary functions:
</p>
<p><br></p>
<pre class="r"><code># Make a dummy data frame:

dummyData &lt;-  data.frame(
  gen = c(&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;),
  n = c(3,5,8,13, 21)
  )

dummyData

# Basic summary statistics of the dummy data frame:

summary(dummyData)

min(dummyData$n)

max(dummyData$n)</code></pre>
<br>
<p>
We often want to see summary values associated with treatment levels. Let’s explore querying <code>dummyData</code> by maximum and minimum values:
</p>
<p><br></p>
<pre class="r"><code># Subset to maximum and minimum values, returning separate results:

dummyData[dummyData$n == min(dummyData$n),]

dummyData[dummyData$n == max(dummyData$n),]

# Subset to maximum and minimum n values, returning both results in one frame:

dummyData[dummyData$n == min(dummyData$n)|
            dummyData$n == max(dummyData$n),]</code></pre>
<br>
<p>
When querying, remember that we can subset by both position and condition. For example, perhaps we were asked to provide the minimum value of n for treatment level “a”. We might address this as:
</p>
<p><br></p>
<pre class="r"><code># Subset to group &quot;a&quot;:

dummyData[dummyData$gen == &#39;a&#39;,]

# As a data frame, we can pull out the second column using indexing ...

dummyData[dummyData$gen == &#39;a&#39;,2]

# ... or by name (my preference):

dummyData[dummyData$gen == &#39;a&#39;,]$n


# We can then calculate the minimum value in group &quot;a&quot; as:

min(dummyData[dummyData$gen == &#39;a&#39;,]$n)</code></pre>
<p><br></p>
</div>
<div id="section-practice-with-real-data" class="section level2">
<h2>Practice with real data</h2>
<p><br></p>
<br>
<p>
We will practice on an example data frame built in to the tidyverse package. The data provided are the size of the human population, by country, from 1995 to 2013 (source: World Health Organization’s Tuberculosis Report, see <a href="http://www.who.int/tb/country/data/download/en/" class="uri">http://www.who.int/tb/country/data/download/en/</a>). Let’s first load and explore the data:
</p>
<p><br></p>
<pre class="r"><code># Load WHO&#39;s TB dataset:

population</code></pre>
<br>
<p>
Notice that this is a tibble data frame. Loading the data as a tibble was very helpful, because only the first 10 records (rows), out of a total of 4,060 total records, are displayed.
</p>
<p><br></p>
<br>
<p>
Let’s explore the population of the United States. We’ll start by subsetting the data to records where the “country” value is the “United States”.
</p>
<p><br></p>
<pre class="r"><code># Subset population data to the United States:

population[population$country == &#39;United States&#39;, ]</code></pre>
<br>
<p>
We’ve done something wrong! There were 0 rows associated with the United States! Perhaps US data are missing or something else is wrong. Let’s use our <code>str_detect</code> function to query countries that contain the name “United” and adjust the statement above:
</p>
<p><br></p>
<pre class="r"><code># What are the country names?

population$country

# That is a very messy result, how about just a vector of unique names?

unique(population$country)

# Which of these countries contain the pattern &quot;United&quot;?

str_detect(unique(population$country), &#39;United&#39;)

unique(population$country)[str_detect(unique(population$country), &#39;United&#39;)]

# They call the United States &quot;United States of America&quot;, so the query could be written as:

population[population$country == &#39;United States of America&#39;,]</code></pre>
<br>
<p>
You can use the above query techniques to extract meaningful data from this dataset. For example, perhaps you are interested in what the population of the United States was in 2004. Query the data to the year 2004 and return the population size, as below:
</p>
<p><br></p>
<pre class="r"><code># To determine the size of a population in 2004:

population[population$year == 2004,]

# Therefore, the data frame reduced to the population of the United States in 2004:

population[population$country == &#39;United States of America&#39; &amp;
             population$year == 2004,]

# To return just the population information:

population[population$country == &#39;United States of America&#39; &amp; 
             population$year == 2004,]$population</code></pre>
<br>
<p>
As another example, you have been asked which years the population of the United States was greater than 300 million. To determine this, subset the population data to only years in which the population was greater than 300,000,000 and return the years vector, as below:
</p>
<p><br></p>
<pre class="r"><code># Subset the population data frame to records with a population of greater than 300 million:

population[population$population &gt; 300000000,]

# Repeat the above, but subset the records to the United States:

# Therefore, the data frame reduced to the population of the United States in 2004:

population[population$country == &#39;United States of America&#39; &amp;
             population$population &gt; 300000000,]

# To return just the years:

population[population$country == &#39;United States of America&#39; &amp;
             population$population &gt; 300000000, ]$year</code></pre>
<hr>

<script type="application/shiny-prerendered" data-context="server-start">

require(knitr)
require(kableExtra)

knitr::opts_chunk$set(echo = TRUE)

# Libraries:
library(tidyverse)

# Functions:

theme_add <- function(){
  theme(
    axis.title = element_text(size = rel(1.5))
  )
}

# Preset values

exampleFactor <- factor(c('three','two','one', 'one'))

exampleFactorLevels <- factor(
  exampleFactor,
  levels = c('one', 'two', 'three')
)

exampleFactorLabels <- factor(
  exampleFactorLevels,
  labels = c('One', 'Two', 'Three')
)

numericVector <- c(1, 1, 2, 3)

</script>
 <!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery-1.11.3"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap-3.3.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]}]}
</script>
<!--/html_preserve-->
</div>

</div> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h2 class="title toc-ignore" style="display:none;">Lesson three: Indexing</h2>
<h4 class="author"><em>Brian S. Evans, Ph.D.</em></h4>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</div> <!-- bandContent page -->
</div> <!-- pageContent band -->




<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>

</html>
