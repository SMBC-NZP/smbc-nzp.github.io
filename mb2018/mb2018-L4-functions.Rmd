---
output:
 html_document:
  theme: yeti
---

<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<style>

code{
  background-color:#f2f2f2;
  border-radius: 25px;
}
 
span.co{
  color:#000080;
  font-weight: bold;
}
 
img{
  display: block;
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 10px;
  padding-bottom: 10px;
}

p{
  text-align: left;
  font-size: 18px;
}

ul, ol{
  line-height: 27px;
  text-align: left;
  font-size: 18px;
  margin-left: 0px;
}
 
blockquote{
  font-size: 18px;
  border-left: 8px solid #292093;
  background-color: #e6ffff;
  padding-left: 16px;
  padding-right: 16px;
}
 
.row{
  margin: auto;
}
 
table {
  border-collapse: collapse;
}

table, td, th {
  border: 1px solid black;
  padding: 5px;
  text-align: center;
  vertical-align: middle;
}
 
 /* Create two equal columns that floats next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

.roundBorder {
  border-radius: 25px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlack {
  border-radius: 25px;
  border: 10px solid #D3D3D3;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlackEx {
  border-radius: 5px;
  border: 5px solid #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}

.roundBorderEx {
  border-radius: 3px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}

.tt {
    position: relative;
    display: inline-block;
    class: inline; 
    font-weight: bold;
    font-family: "Avenir";
    font-size: 18px;
    border-bottom: 1px black;
}

/* Tooltip text */
.tt .ttText {
    visibility: hidden;
    font-weight: normal;
    font-size: 18px;
    width: 200px;
    background-color: black;
    border: 1px solid black;
    color: white;
    text-align: left;
    padding: 5px;
    border-radius: 6px;
    position: absolute;
    z-index: 1;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tt:hover .ttText {
    visibility: visible;
}

</style>

<h1 style="text-align: center;">Introduction to data science in R, Lesson 3:<br/>Writing functions</h1>
<br>
<!img style="float: left; margin: 0px 0px 15px 15px;" src="nzpLogo.jpg" width="150" />
<p style = "text-align: center; font-size: 14px;">Brian S. Evans, Ph.D.<br />
Migratory Bird Center<br/>
Smithsonian Conservation Biology Institute</p>
<hr>

<p>In this lesson we will explore <b><i>for loops</i></b> and <b>functions</b>. A <b><i>for loop</i></b> is code that allows you to repeat an operation a set number of iterations. A function is code that allows you to create or modify objects in a repeatable way. As data analysis often includes many repeated tasks,  <i>for loops</i> and user-defined functions can save considerable time, shorten R scripts, and make your scripts more legible. Understanding how they work is crucial to developing good coding practices.</p>

</p>

<hr>

<h2>Setup for the lesson:</h2>

<p>For this lesson, we will use three example data frames: Iris sepal and petal measurements collected by botanist Edgar Anderson in the 1920's, bird traits collected by Wilman et al. (2014), and bird point count observations from Washington, DC (Evans et al. 2016).</p>

<p>Open R Studio and run the following lines of code to load the data into R:</p>
<br>

```{r, eval=FALSE}
#=================================================================================*
# ---- set up ----
#=================================================================================*

# Load libraries

library(RCurl)

library(tidyverse)

# Note: If you have yet to install these library, please do so with: 
# install.packages('rCurl') ; install.packages('tidyverse')

# Provide the web addresses of the files (note: iris is preloaded example data):

url <- 'https://raw.githubusercontent.com/bsevansunc/workshop_languageOfR/master'

habitsURL <- getURL(
  paste(url, 'birdHabits.csv', sep = '/')
  )

countsURL <- getURL(
  paste(url, 'birdCounts.csv', sep = '/')
  )

# Read in the data:

birdHabits <- tbl_df(
  read.csv(text = habitsURL, stringsAsFactors = FALSE)
  )

birdCounts <- tbl_df(
  read.csv(text = countsURL, stringsAsFactors = FALSE)
  )


# Clean up iris for analysis:

irisTbl <- tbl_df(iris)

names(irisTbl) <-
  c('sepalLength',
    'sepalWidth',
    'petalLength',
    'petalWidth',
    'species')
```

<br>
<p>For the iris dataset, I think it's best to do some familiar cleaning steps:</p>
<br>

```{r, eval=FALSE}

# Clean up iris for analysis:

irisTbl <- tbl_df(iris)

names(irisTbl) <-
  c('sepalLength',
    'sepalWidth',
    'petalLength',
    'petalWidth',
    'species')
```
<hr>

<p>In the previous lessons, we worked with several functions (e.g., "c", "mean"). Functions allow you to simplify complex tasks, which is especially useful if you need to run a task multiple times. Program R contains many functions and many more still are created by R users and provided to the R community as collections of functions known as packages (or libraries). As datasets and data handling needs are often distinct, relying exclusively on built-in and community-defined functions is limiting.</p>
<p><b>Why would you write your own functions?</b> Learning how to create your own functions, or customize existing functions, provides you with the flexibility to solve unique problems, shorten your script, and make your R code more legible for others. Writing your own functions is easy, as long as you follow the correct syntax. The basic structure is (<b>DO NOT RUN</b>):</p>
<br>

```{r, eval=FALSE}
functionName <- function(functionTarget) {
	functionBody: What you would like to happen when you run your function
}
```
<br>

<p>Let's illustrate writing functions with a pretty silly example -- a function that will add 1 to any value. Below, we assign a name to the function, `addOneFun <-`, tell R that the code in the enclosing curly brackets is a function of some object `x` (`function(x)`), and provide the argument the function will be evaluated and returned (`x + 1`). </p>
<br>

```{r, eval=FALSE}

# First function:

addOneFun <- function(x){
	x+1
}

# Testing the function on a numeric value:

42+1

addOneFun(42)

# Testing the function on a vector of numeric values:

v <- c(1,1,2,3,5)

v + 1

addOneFun(v)
```
<br>

<p>If you are doing a lot of data <b>querying</b>, writing your own query functions can be a great way to make your code more legible. Let's use the `birdCounts` data to explore writing custom query functions. For example, perhaps you frequently need to query the number of individuals of a given species at each site:</p>
<br>

```{r queryFun, eval = FALSE}

# Query by species function:

speciesSubset <- function(spp){
  birdCounts[birdCounts$species == spp, ]
}

# Test function:

birdCounts[birdCounts$species == 'grca', ]

speciesSubset('grca')

```
<br>
<p>It's best to write your functions as general as possible. For example, the species subset function above is great if you are going to query just the `birdCounts` data frame. If you also intend to query the `birdHabits` frame by species, you may want to make the data frame one of the arguments.</p>
<br>

```{r query generalize fun, eval = FALSE}

# Query by species function, generalized:

speciesSubset <- function(dfIn, spp){
  dfIn[dfIn$species == spp, ]
}

# Test function, birdCounts:

birdCounts[birdCounts$species == 'grca', ]

speciesSubset(birdCounts, 'grca')

# Test function, birdHabits:

birdHabits[birdHabits$species == 'grca', ]

speciesSubset(birdHabits, 'grca')
```

<br>
<p>Another way to generalize a query function is to make the query field one of the arguments of the function. Note that the below statements are equivalent:</p>
<br>

```{r query generalize fun 2, eval = FALSE}
# Subset to catbirds using $ and matrix notation:

birdHabits[birdHabits$species == 'grca', ]

birdHabits[birdHabits[,'species'] == 'grca',]
```

<br>
<p>Because of this, we can write a VERY general function to query any data frame!</p>
<br>

```{r query generalize fun 3, eval = FALSE}
# Very generalized query:

query <- function(dfIn, variable, condition){
  dfIn[dfIn[,variable] == condition,]
}

# Test query:

birdHabits[birdHabits$species == 'grca', ]

birdHabits[birdHabits[,'species'] == 'grca',]

query(birdHabits, 'species', 'grca')
```

<br>
<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise One:</h3>
<br>
<ol>
<li>Write a function to subset the `birdHabits` data frame to just ground foraging birds.</li>
<li>Write a function that will calculate the total number of individuals observed of a given species in the `birdCounts` data frame(i.e., the sum of count for a data frame subset by species)</li>
</ol>
<br>
</blockquote>
<br>
<hr>
<br>

<p>Functions can sometimes get pretty long and include multiple objects. When this is the case, it's good practice to include `return` to illustrate which object is being returned. Let's write a function in multiple steps that calculates the average (mean) number of individuals of a given species observed on a point count.</p>
<br>

```{r query mean fun, eval = FALSE}

# Query function, mean count:

meanSpeciesCounts <- function(spp){
  # Number of unique site values:
  nSites <- length(unique(birdCounts$site))
  # Subset birdCounts to the species of interest:
  birdCounts_sppSubset <- birdCounts[birdCounts$species == spp, ]
  # Calculate the total number of birds observed:
  nBirds <- sum(birdCounts_sppSubset$count)
  # Return mean number of birds per site:
  return(nBirds/nSites)
}

# What is the average number of observed catbirds?

meanSpeciesCounts('grca')
```
<br>
<p>Note in the above that the objects nSites, birdCounts_sppSubset, and nBirds were not placed in your <b>global environment</b>. Objects defined within the function body are only defined inside the function, not the global environment.</p>
<p>Functions can also be <b>nested</b>. In other words, functions can include user-defined functions written inside the function body. We have already done this quite a bit with functions in base R. For example, the `length` function above is nested inside our user-defined function `meanSpeciesCounts`. Let's try to nest our `speciesSubset` function inside the `meanSpeciesCounts` function above.</p>
<br>
```{r query mean fun2, eval = FALSE}

# Query by species function, generalized:

meanSpeciesCounts <- function(dfIn, spp){
  # Number of unique site values:
  nSites <- length(unique(dfIn$site))
  # Calculate the total number of birds observed:
  nBirds <- sum(speciesSubset(dfIn, spp)$count)
  # Return mean number of birds per site:
  return(nBirds/nSites)
}

# What is the average number of observed catbirds?

meanSpeciesCounts(birdCounts, 'grca')
```
<br>

<blockquote>
<h3><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Two:</h3>
<br>
<ol>
<li>Using the `birdHabits` data frame, write a function to count the number of species in a given diet and foraging guild.</li>
<li>The mathematical formula for standard error is provided below. Convert this to an R function (<b>Note</b>: the function for standard deviation is `sd` and the function for square root is `sqrt`):</li>
$$StdErr (x) = \frac{StDev(x)}{\sqrt{n}}$$
</ol>
<br>
</blockquote>
<br>
<hr>
<br>