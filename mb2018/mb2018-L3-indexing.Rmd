---
title: "Lesson three: Indexing"
author: "Brian S. Evans, Ph.D."
output: learnr::tutorial
runtime: shiny_prerendered
theme: yeti
---

<!-- html head --> 

<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" href="css/styles.css">
<!--link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"-->
</head>


```{r setup, include = FALSE}

require(knitr)
require(kableExtra)

knitr::opts_chunk$set(echo = TRUE)

# Libraries:
library(tidyverse)

# Functions:

theme_add <- function(){
  theme(
    axis.title = element_text(size = rel(1.5))
  )
}

# Preset values

exampleFactor <- factor(c('three','two','one', 'one'))

exampleFactorLevels <- factor(
  exampleFactor,
  levels = c('one', 'two', 'three')
)

exampleFactorLabels <- factor(
  exampleFactorLevels,
  labels = c('One', 'Two', 'Three')
)

numericVector <- c(1, 1, 2, 3)

```

## Introduction

<p>In this lesson we will be exploring how to query data using what is often called "indexing" or "matrix notation". We will learn a <b>much easier</b> way to query data by the end of this workshop. I start by teaching this method of querying because it is helpful in understanding how R objects work, gives a glimpse of what is happening under the hood when using other querying techniques, and still used for some advanced querying techniques.</p>

## Review: logical values

<br>
<p>Recall that logical values can be obtained by evaluating objects with <b>logical operators</b>. For example, the logical operator `==` tests whether a value is equal to another value.</p>
<br>

<div class = "reviewDiv">
<p><i class="fa fa-user-circle-o" aria-hidden="true" style = "font-size: 150%"></i> Use the logical operator `==` to test whether the each set of values is equivalent ($\equiv$).</p>

<p>$21 \equiv 34$</p>

```{r logic1, exercise = TRUE, exercise.lines = 3}

```

```{r logic1-hint}
21 == 34
```

<p>$21 \equiv 21$</p>

```{r logic2, exercise = TRUE, exercise.lines = 3}

```

```{r logic2-solution}
21 == 21
```

<p>$21 \equiv 34 - 13$</p>

```{r logic3, exercise = TRUE, exercise.lines = 3}

```

```{r logic3-solution}
21 == 34 - 13
```

<p>$34 \equiv 21 + 13$</p> 

```{r logic4, exercise = TRUE, exercise.lines = 3}

```

```{r logic4-hint-1}
34 == 21 + 13
```

<p>$21 \equiv 13 - 34$</p>

```{r logic5, exercise = TRUE, exercise.lines = 3}

```

```{r logic5-solution}
21 == 13 - 34
```

<p>$(21 \equiv 34) + (34 \equiv 21 + 13)$</p>

```{r logic6, exercise = TRUE, exercise.lines = 3}

```

```{r logic6-solution}
(31 == 34) + (34 == 21 + 13)
```

</div>


<br>

## Using logic with objects

<br>
<p>We can run a logic test on objects with more than one value. In the following examples, R tests whether each value in the objects below are equal to 3 and returns logical values in the dimensions of the object.</p>
<br>

```{r logic with objects, eval = FALSE}
# Generate and evaluate whether values in vector v are equal to 3:

v <- c(1,1,2,3,5,8)

v

v == 3

# Generate and evaluate whether values in matrix m are equal to 3:

m <- matrix(v, ncol = 2)

m

m == 3

# Generate and evaluate whether values in data frame df are equal to 3:

df <- as.data.frame(m)

df

df == 3
```
<br>

## The logical operators

<h3>Comparing values</h3>

<br>
<p>The table below provides a set of the logical operators that are most commonly used to compare values. In each of the table items we are evaluating some object (or value) x relative to some object y.</p>
<br>

```{r echo = FALSE}
df <-
  data.frame(
  `Operator` = c('==', '!=', '|', '&', '<', '<=', '%in%','>', '>='),
  `Usage` = c('x == y', 'x != y', 'x | y', 'x & y','x %in% yz', 'x < y', 'x <= y', 'x > y', 'x >= y'),
  `Meaning` = c(
    'x is equal to y',
    'x is NOT equal to y',
    'x OR y',
    'x AND y',
    'x is in the vector c(y,z)',
    'x is less than y',
    'x is less than or equal to y',
    'x is greater than y',
    'x is greater than or equal to y')
  )

kable(df, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = 'left', font_size = 14)
```

<p>Each of the logical operators above can be applied in the same way that we have applied `==` thus far. Try out the code below, then conduct your own logical tests to explore their application further.</p>
<br>

```{r explore logical operators with v, eval = FALSE}

# Explore logical operators with vector v:

v

v != 3

!(v == 3)

v < 3

v <= 3

v > 3

v >= 3

```

<br>

<p>Repeat the above with your matrix, `m`, and data frame, `df`.</p>
<br>

<h3>Comparing sets</h3>

<br>

<p>We are often interested in comparing sets of values with one another. Using the code above, we may be interested in testing whether values `1` and `3` appear in vector `v`. To do so, we use the operator `%in%`, which tests the logic statement "is in".</p>
<br>

```{r using in, eval = FALSE}
# Test whether values in v match values 1 or 3:

v %in% c(1,3)

```
<br>

<p>The NOT statement, `!x`, wasn't very useful before. In combination with `%in%`, it becomes a powerful tool to examine sets.</p>

```{r using in and not, eval = FALSE}
# Test whether values in v match values 1 or 3:

!(v %in% c(1,3))

```

<br>
<p>You can also compare sets with <i>and/or</i> statements, represented in R by `&` and `|`.</p>
<br>

```{r using and or, eval = FALSE}
# Test whether values in v match values 1 OR 3:

v == 1 | v ==3

# Test whether values in v match values 1 AND 3:

v == 1 & v == 3

```

<br>
<p>The first statement above, OR, is equivalent to our previous `v %in% c(1,3)`. The latter, AND, is not very useful in this case, because none of the values can be both 1 and 3 at the same time.</p>
<br>

<p>The AND operator becomes very useful when querying across multiple conditions. For example, if we wanted to test whether a value was less than 5 and not equal to 2, we would write this out as:</p>
<br>

```{r better use of and, eval = FALSE}
# Test whether values in v are less than 5 and not equal to 2:

v < 5 & v != 2

```

<br>
<p>Logic can get pretty hairy fairly quickly with AND/OR statements. It's good to have a sense of how to tackle more complex statements using these operators. Have a look at the code below and be sure you understand how it is evaluated.</p>
</br>

```{r complex and or, eval = FALSE}
# Test whether values in v are less than 5 and not equal to 2 OR equal to eight:

v < 5 & v != 2 | v == 8

```
<br>

## Indexing and logic

<h3>Querying vectors</h3>

<br>
<p>Recall that the position of value `x` in vector `v` would be notated as `v[x]` and that we can use this information to index vector `v` as follows:</p>
<br>

```{r vector index review, eval = FALSE}
# Use indexing to subset a vector:

v[3]

v[3:4]

v[c(1,3)]

```

<br>
<p>In indexing the vector with `v[3]` above, you essentially instructed R to evaluate and return the statement "vector `v` where position v<sub>x</sub> is equal to 3". R returned all of the values from vector `v` for which this statement was `TRUE`. In other words, you conducted a query of vector `v` by <b>position</b>.</p>
<br>

<p>You may also query values by <b>condition</b>, using logic, in the same manner as above. For example, you may want R to evaluate the statement "vector `v` where value v<sub>x</sub> is greater than two":</p>
<br>

```{r logic query vector, eval = FALSE}
# Use logic to subset a vector:

v

v > 2

v[v > 2]

```


<br>
<p>Notice in the above that the line `v > 2` returned logical values of `v` associated with that test. The next line of code, `v[v > 2]` returned values from `v` that met this condition.</p>
<br>

<p>Why does this work? Let's take a quick look under the hood. The function `which` provides the index location of a logical statement. Using the `v > 2` query above, we can see that:</p>
<br>

```{r logic query with which, eval = FALSE}
# At which indices does our logical statement evaluate to TRUE?

v

v > 2

which(v > 2)

v[4:6]

v[v > 2]
```
<br>
<p>All of the various logical statements can be applied in the same manner. Please take a moment to query vector `v` based on the following conditions:</p>
<ul>
<li>Values greater than or equal to 3</li>
<li>Values that do not equal 2</li>
<li>Values that equal 2</li>
<li>Values that are greater than or equal to 3 but do not equal 5</li>
<li>Values that are 3 or 5</li>
</ul>
<br>

<h3>Querying matrices</h3>

<br>
<p>Recall that the position of value `x,y` (row, column) in a matrix, `m`, can be notated as `m[x,y]`. We can use this information to index matrix `m` as follows:</p>
<br>

```{r matrix index, eval = FALSE}
# Index by matrix m by row (x) and column (y) position [x,y]:

m[1,1]

m[2,2]

m[2, ]

m[ ,2]

m[1:2,2]

```


<br>
<p>Working with what is often called "matrix notation" to query objects can be a bit tricky to wrap your head around at first. Let's start by evaluating `m[,]`, which returns all of the rows and columns of matrix `m`:</p>
<br>

```{r mAll, eval = FALSE}
# All rows and columns of m:

m[,]

```

<br>
<p>The statement `m[,1]` subsets m to all of the rows of the first column. As above, we are evaluating "matrix `m` where position m<sub>y</sub> is equal to 1". </p>
<br>

```{r mSubsetColumn, eval = FALSE}
# A vector of values associated with the first column of matrix m:

m[,1]

```

<br>
<p>We can evaluate vector `m[,1]` using logic. For example, let's test `m[,1]` to determine whether each value is greater than 1:</p>
<br>

```{r m just logic, eval = FALSE}
# Logical test of whether the first column of m is greater than 1:

m[,1] > 1

```

<br>
<p>We see that this statement only evaluates as TRUE at one position in the vector. Let's use `which`, as above, to determine the index associated with this position:</p>
<br>

```{r m logic with which, eval = FALSE}
# At which indices does our logical statement evaluate to TRUE?

which(m[,1] > 1)

```

<br>
<p>Because our `which` statement evaluates to 3, the following queries are equivalent:</p>
<br>

```{r m query with which, eval = FALSE}
# Query m by index and logical statement:

m[3, ]

m[m[,1] > 1, ]

```

<br>
<p>Querying using "matrix notation" tends to be hard to read because of the ways that columns have to be specified. For example a query of column two, in which the first column is less than two and the second column is less than 5 would be written as:</p>
<br>

```{r m query complicated, eval = FALSE}
# Querying matrix by column 1 less than 2 and column 2 less than 5

which(m[,1] < 2 &  m[,2] < 5)

m[m[,1] < 2 &  m[,2] < 5 , ]

```

<br>

<h3>Querying data frames</h3>

<br>
<p>Recall that the position of value `x,y` (row, column) in a data frame, `df`, can be notated as `df[x,y]`. We can use this information to index data frame `df` as follows:</p>
<br>

```{r data frame index, eval = FALSE}
# Index by matrix m by row (x) and column (y) position [x,y]:

df[1,1]

df[2,2]

df[2, ]

df[ ,2]

df[1:2,2]

```

<br>
<p>As you might expect, querying data frames using "matrix notation" is exactly the same as querying matrices. Recall, however, that data frames has a "names" slot built in:</p>
<br>

```{r data frame attributes, eval = FALSE}
# Attributes of object df:

attributes(df)
```

<br>
<p>These names can be set and reset as needed:</p>
<br>

```{r data frame reset names, eval = FALSE}

# Reset names of object df:

names(df) <- c('hello', 'world')

df

attributes(df)
```


<br>
<p>Recall that the component vectors in a data frame (i.e., columns -- in this case `c(1,1,2)` and `c(3,5,8)`) can be accessed by name using the `$` notation:</p>
<br>

```{r data frame extract by name, eval = FALSE}

# Data frame indexing by position ...

df[,1]

df[,2]

# ... is equivalent to:

df$hello

df$world

```

<br>
<p>The above is very useful for querying data frames, because the `$` notation is much easier to read than "matrix notation". For example:</p>
<br>

```{r data frame query by position and name, eval = FALSE}

# Querying data frames using "matrix notation" ...

df[,1] > 1

which(df[,1] > 1)

df[df[,1] > 1,]

# ... is equivalent to using column names:

df$hello > 1

which(df$hello > 1)

df[df$hello > 1,]

```

<br>
<p>In the matrix section, we queried matrix `m` such that values of column one are less than 2 and values of column two are less than 5. Repeat this query on data frame `df` using "matrix notation" and the column names of `df`.</p>
<br>

## Working with strings
<br>
<br>
<p>Strings are notoriously difficult to work with when cleaning data. Luckily the tidyverse libraries contain the package "stringr" that simplifies the process of working with strings. We won't dive too deeply into the string realm here, but it is important to have some idea of how they work.</p>
<br>

<br>
<p>We'll start by loading the tidyverse and an example dataset, "fruit".</p>
<br>

```{r load fruits, eval = FALSE} 
library(tidyverse)

fruit

```

<br>
<p>Note that `fruit` is simply a vector of fruit names. Strings can be indexed like any other value:</p>
<br>

```{r index fruits, eval = FALSE} 

# Query the first five fruits by index:

fruit[1:5]

```

<br>
<p>Strings have many different characteristics that can be used for querying. We've already explored the simplest of them, `is equal to`. Let's see how this works:

```{r fruit by full name, eval = FALSE} 

# Let's look at our vector of fruit again:

fruit

# If there are duplicate entries (there are not), you can use "unique":

unique(fruit)

# There is just one apple!

fruit == 'apple'

# Which position in the fruit vector is apple?

which(fruit == 'apple')

# Subsetting to fruits named "apple" by position ...

fruit[1]

# ... is equivalent to:

fruit[which(fruit == 'apple')]

# ... and is also equivalent to subsetting by condition:

fruit[fruit == 'apple']
```

<br>
<p>You can use the function `str_sub` to extract characters from strings by their position within the string. It takes as arguments the string being evaluated, the start point of the string, and the end point. Let's take a moment to explore how this function works:</p>
<br>

```{r hello world str_sub, eval = FALSE}
# Using str_sub, generate an example phrase: 

examplePhrase <- 'hello world'

examplePhrase

# Subset to just "hello":

str_sub(examplePhrase, start = 1, end = 5)

# Subset to just "world":

str_sub(examplePhrase, start = 7, end = 12)

# You actually don't have to specify the end point here:

str_sub(examplePhrase, start = 7)

# You can also count from the end:

str_sub(examplePhrase, start = -5)

```

<br>
<p>The function `str_sub` can be used to query a vector of strings. For example, perhaps we wanted to query fruits, subsetting to those that start with the letter "a":</p>
<br>

```{r fruit by str_sub, eval = FALSE} 

# str_sub can be used to extract the first letter of each value:

fruit

str_sub(fruit, start = 1, end = 1)

# Which fruits start with the letter "a"?

str_sub(fruit, start = 1, end = 1) == 'a'

which(str_sub(fruit, start = 1, end = 1) == 'a')

# Subsetting to fruits with 7 characters by index ...

fruit[1:3]

# ... is equivalent to ...

fruit[which(str_sub(fruit, start = 1, end = 1) == 'a')]

# ... and is also equivalent to subsetting by condition:

fruit[str_sub(fruit, start = 1, end = 1) == 'a']
```

<br>
<p>We can also query by the number of characters (i.e., symbols, numbers, or letters) in the string. For example, perhaps we're not interested in "apple" but rather any fruit that has five letters:</p>
<br>

```{r fruit by str_count, eval = FALSE} 

# str_count can be used to determine the number of letters or symbols in a string:

fruit

str_count(fruit)

# Which fruits have exactly 5 letters?

str_count(fruit) == 5

which(str_count(fruit) == 5)

# Subsetting to fruits with 5 characters by index ...

fruit[c(1,34,36,44,49,53,58)]

# ... is equivalent to ...

fruit[which(str_count(fruit) == 5)]

# ... and is also equivalent to subsetting by condition:

fruit[str_count(fruit) == 5]
```

<br>
<p>Probably the most useful function for querying strings is `str_detect`. This function is a logical test of whether a provided pattern is present in a target value. For example, we might explore the example phrase "hello world" as such:</p>
<br>

```{r hello world str_detect, eval = FALSE} 
# Detecting a pattern within a string:

examplePhrase

str_detect(examplePhrase, pattern = 'hello')

str_detect(examplePhrase, pattern = 'ello')

str_detect(examplePhrase, pattern = 'lo wo')

str_detect(examplePhrase, pattern = 'world')

str_detect(examplePhrase, pattern = "foo")

str_detect(examplePhrase, pattern = 'helloworld')

```

<br>
<p> Let's use `str_detect` to subset the `fruit` vector to only fruits that contain the word "apple":</p>
<br>

```{r fruit by str_detect, eval = FALSE} 

# str_detect can be used to test whether a pattern is present in a string:

fruit

# Which fruits contain the pattern "apple"?

str_detect(fruit, 'apple')

which(str_detect(fruit, 'apple'))

# Subsetting to fruits with the pattern "apple" by index ...

fruit[c(1,62)]

# ... is equivalent to ...

fruit[which(str_detect(fruit, 'apple'))]

# ... and is also equivalent to subsetting by condition:

fruit[str_detect(fruit, 'apple')]
```

<br>

## Summarizing and queries

<br>
<p>Querying with indexing and logic can be a great way to summarize your data. Let's generate a fake data frame and explore the `min` (minimum value in a set) and `max` (maximum value in a set) summary functions:</p>
<br>

```{r dummy data minMax, eval = FALSE}

# Make a dummy data frame:

dummyData <-  data.frame(
  gen = c('a', 'b', 'a', 'a', 'b'),
  n = c(3,5,8,13, 21)
  )

dummyData

# Basic summary statistics of the dummy data frame:

summary(dummyData)

min(dummyData$n)

max(dummyData$n)

```

<br>
<p>We often want to see summary values associated with treatment levels. Let's explore querying `dummyData` by maximum and minimum values:</p>
<br>

```{r dummy data minMax subset, eval = FALSE}

# Subset to maximum and minimum values, returning separate results:

dummyData[dummyData$n == min(dummyData$n),]

dummyData[dummyData$n == max(dummyData$n),]

# Subset to maximum and minimum n values, returning both results in one frame:

dummyData[dummyData$n == min(dummyData$n)|
            dummyData$n == max(dummyData$n),]

```

<br>
<p>When querying, remember that we can subset by both position and condition. For example, perhaps we were asked to provide the minimum value of n for treatment level "a". We might address this as:</p>
<br>

```{r dummy data minMax subset extract, eval = FALSE}

# Subset to group "a":

dummyData[dummyData$gen == 'a',]

# As a data frame, we can pull out the second column using indexing ...

dummyData[dummyData$gen == 'a',2]

# ... or by name (my preference):

dummyData[dummyData$gen == 'a',]$n


# We can then calculate the minimum value in group "a" as:

min(dummyData[dummyData$gen == 'a',]$n)

```

<br>

## Practice with real data

<br>

<br>
<p>We will practice on an example data frame built in to the tidyverse package. The data provided are the size of the human population, by country, from 1995 to 2013 (source: World Health Organization's Tuberculosis Report, see http://www.who.int/tb/country/data/download/en/). Let's first load and explore the data:</p>
<br>

```{r tb data load, eval = FALSE}

# Load WHO's TB dataset:

population
```

<br>
<p>Notice that this is a tibble data frame. Loading the data as a tibble was very helpful, because only the first 10 records (rows), out of a total of 4,060 total records, are displayed.</p>
<br>

<br>
<p>Let's explore the population of the United States. We'll start by subsetting the data to records where the "country" value is the "United States".</p>
<br>
```{r us population data fail, eval = FALSE}

# Subset population data to the United States:

population[population$country == 'United States', ]

```
<br>
<p>We've done something wrong! There were 0 rows associated with the United States! Perhaps US data are missing or something else is wrong. Let's use our `str_detect` function to query countries that contain the name "United" and adjust the statement above:</p>
<br>

```{r us population United query, eval = FALSE}

# What are the country names?

population$country

# That is a very messy result, how about just a vector of unique names?

unique(population$country)

# Which of these countries contain the pattern "United"?

str_detect(unique(population$country), 'United')

unique(population$country)[str_detect(unique(population$country), 'United')]

# They call the United States "United States of America", so the query could be written as:

population[population$country == 'United States of America',]

```

<br>
<p>You can use the above query techniques to extract meaningful data from this dataset. For example, perhaps you are interested in what the population of the United States was in 2004. Query the data to the year 2004 and return the population size, as below:</p>
<br>

```{r us population 2004, eval = FALSE}

# To determine the size of a population in 2004:

population[population$year == 2004,]

# Therefore, the data frame reduced to the population of the United States in 2004:

population[population$country == 'United States of America' &
             population$year == 2004,]

# To return just the population information:

population[population$country == 'United States of America' & 
             population$year == 2004,]$population

```

<br>
<p>As another example, you have been asked which years the population of the United States was greater than 300 million. To determine this, subset the population data to only years in which the population was greater than 300,000,000 and return the years vector, as below:</p>
<br>

```{r us population greater than 300M, eval = FALSE}

# Subset the population data frame to records with a population of greater than 300 million:

population[population$population > 300000000,]

# Repeat the above, but subset the records to the United States:

# Therefore, the data frame reduced to the population of the United States in 2004:

population[population$country == 'United States of America' &
             population$population > 300000000,]

# To return just the years:

population[population$country == 'United States of America' &
             population$population > 300000000, ]$year


```

<hr>