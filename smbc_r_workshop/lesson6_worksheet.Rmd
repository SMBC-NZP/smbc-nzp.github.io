---
output:
 html_document:
  theme: yeti
---

<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<style>

code{
  background-color:#f2f2f2;
  border-radius: 25px;
}
 
span.co{
  color:#000080;
  font-weight: bold;
}
 
img{
  display: block;
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 10px;
  padding-bottom: 10px;
}

h4{
  text-align: left;
  font-size: 20px;
}

p{
  text-align: left;
  font-size: 16px;
}

ul, ol{
  line-height: 27px;
  text-align: left;
  font-size: 16px;
  margin-left: 0px;
}
 
blockquote{
  font-size: 18px;
  border-left: 8px solid #292093;
  background-color: #e6ffff;
  padding-left: 16px;
  padding-right: 16px;
}
 
.row{
  margin: auto;
}
 
table {
  border-collapse: collapse;
}

table, td, th {
  border: 1px solid black;
  padding: 5px;
  text-align: center;
  vertical-align: middle;
}
 
 /* Create two equal columns that floats next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

.roundBorder {
  border-radius: 25px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlack {
  border-radius: 25px;
  border: 10px solid #D3D3D3;
  padding-left: 20px;
  padding-right: 20px;
  padding-top: 10px;
  padding-bottom: 10px;
}

.roundBorderBlackEx {
  border-radius: 5px;
  border: 5px solid #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}

.roundBorderEx {
  border-radius: 3px;
  border: 5px solid #30288C;
  background: #D6EAF8;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 2px;
}

.tt {
    position: relative;
    display: inline-block;
    class: inline; 
    font-weight: bold;
    font-family: "Avenir";
    font-size: 18px;
    border-bottom: 1px black;
}

/* Tooltip text */
.tt .ttText {
    visibility: hidden;
    font-weight: normal;
    font-size: 18px;
    width: 200px;
    background-color: black;
    border: 1px solid black;
    color: white;
    text-align: left;
    padding: 5px;
    border-radius: 6px;
    position: absolute;
    z-index: 1;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tt:hover .ttText {
    visibility: visible;
}

</style>

```{r, eval = TRUE, include  = FALSE}
# Load libraries:

library(RCurl)
library(lubridate)

# Load a source script:

script <-
  getURL(
    "https://raw.githubusercontent.com/bsevansunc/workshop_languageOfR/master/sourceCode.R"
  )

# Evaluate then remove the source script:

eval(parse(text = script))

rm(script)

library(knitr) ; library(kableExtra)

options(knitr.table.format = "html")
```

<h1 style="text-align: center;">Introduction to data science in R, Lesson 6:<br/>Working with tidy data</h1>
<br>
<!img style="float: left; margin: 0px 0px 15px 15px;" src="nzpLogo.jpg" width="150" />
<p style = "text-align: center; font-size: 14px;">Brian S. Evans, Ph.D.<br />
Migratory Bird Center<br/>
Smithsonian Conservation Biology Institute</p>
<hr>

<h2>Introduction</h2>

<p>With increasing calls for openness and reproducibility in science, the need is emerging for better data management practices. With the movement towards open science, data and scripts become part of the data reporting process. This helps advance scientific knowledge, as researchers do not have to reinvent the wheel every time they conduct a similar analysis, and ensures replicability, as interested parties (e.g., reviewers) can repeat every step in your data analysis. Considering this, it is in all of our best interest that our data be formatted correctly, that wrangling steps are clear and easy-to-follow, and that we can avoid "script bloat" by using methods (such as functions and occasionally <i>for loops</i>!) to reduce the length of our scripts. It is highly recommended that you take a "cradle-to-grave" approach to data manipulation and analysis:</p>
<br>
<img src="rWorkshop/images/dsWorkflowOverview.png" 
	title="data science workflow"
	alt = "data science diagram"
	style= "float: right; width: 360px; padding-right: 0px"/>
<ul>
<li>Collect and store your data in tidy spreadsheets and (better yet) <b>databases</b>.</li>
<li>DO NOT complete ANY step in the data manipulation process in Excel! Doing so makes it difficult for others to truly replicate your analyses.</li>
<li>Basic formatting steps to prepare your data for analysis, <b>data tidying</b>, should be completed prior to any summarizing, further cleaning, or analysis of data.</li>
<li>Clean data, including removing "bad" records, such as NA values (i.e., "Not Available") and extreme outliers, prior to (not during) statistical analysis.</li>
</ul>
<br>
<p>In this lesson we will explore creating a tidy workflow by diving deeper into data wrangling in the <i>tidyverse</i>. Our learning goals for this lesson include:</p>

<ol>
<li>Nested functions and code (<i>review</i>)</li>
<li>The pipe (<i>review</i>)</li>
<li>Joining data</li>
<li>Subsetting data</li>
<ul>
<li>Subset columns: Select (<i>review</i>)</li>
<li>Subset rows: Filter</li>
</ul>
<li>Adding and modifying columns</li>
<li>Grouping data</li>
<li>Summarizing data</li>
</ol>

<hr>

<h2>Before we begin</h2>
<p>Copy, paste, and run the following code in R Studio to load the packages and read in the data that we will be using for this lesson:</p>
```{r, eval=FALSE}
# Load RCurl library:

library(RCurl)

# Load a source script:

script <-
  getURL(
    "https://raw.githubusercontent.com/bsevansunc/workshop_languageOfR/master/sourceCode.R"
  )

# Evaluate then remove the source script:

eval(parse(text = script))

rm(script)
```
<br>
<hr>

<h2>The nested function</h2>
<br>
<p>Like all functions, the `tidyverse` functions above can be <b>nested</b> within the other. Nesting helps avoid assigning intermediate objects -- this reduces the number of objects that are stored in your R environment. An advantage of this is that it also reduces the number of names you have to assign to objects, and, of course, the number of names that you have to remember ("What did I call that ... ?"). We've used nested functions quite a bit throughout this workshop thus far. Let's take a moment to review nested and non-nested versions of functions.</p>

<p>To illustrate nested and non-nested code-writing, we will conduct the following analysis:</p>

$$Z_{1} = [1,2,3,4,5]$$
$$Z_{2} = 2(Z_{1})$$
$$Z_{3} = Z_{2}+1$$

<p>Note that the steps in this analysis are <b>chained</b> -- each step is dependent on output from the previous step. Let's begin to evaluate these statements by first defining the values for vector Z1:</p>
```{r nested functions define z1, eval = FALSE}
# Initial values:

Z1 <- 1:5
```
<br>
<p>Next, let's write functions for the second and third steps of this process:</p>
```{r nested functions, eval = FALSE}
# Some very silly functions for illustration:

multiplyByTwo <- function(x){
  x*2
}

addOne <- function(x){
  x+1
}
```
<br>
<p>To carry out this chained analysis, one non-nested option is to complete the process by assigning a new object for each step. What are the advantages and disadvantages of the below?</p>
```{r nested nonnest new object, eval = FALSE}
# Non-nested, new object for each step:

z1 <- 1:5

z2 <- multiplyByTwo(z1)

addOne(z2)
```
<br>
<p>Another non-nested option is to complete the process by overwriting the origin object for each step. What are the advantages and disadvantages of the below?</p>
```{r nested nonnest overwrite object, eval = FALSE}
# Non-nested, overwrite object for each step:

z <- 1:5

z <- multiplyByTwo(z)

addOne(z)
```
<br>
<p>We can also write the process as nested functions. What are the advantages and disadvantages of the below?</p> 
```{r nested version, eval = FALSE}
# Nested:

addOne(multiplyByTwo(1:5))
```
<br>
<p>Take a moment to consider the nested and non-nested versions of the process above. Each has its strengths and weaknesses:</p>
<ul>
<li><b>Non-nested with new object</b>:
<ul>
<li>Strength: Easy to read.</li>
<li>Weaknesses: Takes up a lot of script space. Includes an intermediate object assignment (`z1`) that may be hard to remember.</li>
</ul>
</li>
<li><b>Non-nested with overwritten object</b>:
<ul>
<li>Strengths: Easy to read. No new names.</li>
<li>Weaknesses: Takes up a lot of script space. Loss of the initial value of `z` (<i>never, never, never overwrite assigned objects!</i>).</li>
</ul>
</li>
<li><b>Nested</b>:
<ul>
<li>Strengths: Concise. No new names.</li>
<li>Weaknesses: It is very difficult to read -- the object of the line of code is `1:5` therefore the code is read from the inside out.</li>
</ul>
</li>
</ul>

<hr>
<h2>The pipe</h2>
<br>
<p>One of the greatest recent advancements in the world of R is the implementation of the <b>pipe operator</b>. A pipe operator allows you to set the output of one process as the input of another -- thus sequences of calculations are chained together without having to define intermediate steps as R objects (_Note: Piping is sometimes called chaining_). Piping was first implemented in R by ecologist and R guru Ben Bolker, in an answer to a question on stackoverflow. <img style="PADDING-LEFT:25px; PADDING-TOP: 5px" align = "right" src="https://upload.wikimedia.org/wikipedia/en/b/b9/MagrittePipe.jpg" height="300px" width = "300"/>  Hadley Wickham introduced his version of piping to his `dplyr` package in 2013 while concurrently Stefan Milton Bache developed a more flexible version for his package `magrittr` (named after Magritte's painting, <i>The Treachery of Images</i>). In 2014, Wickham and Bache teamed up and Bache's pipe was incorporated into the `tidyverse`.</p>

<p>Piping makes scripts more readable and easier to write. Moreover, if you didn't do a great job naming your R objects, you may have a hard time remembering what each was. The alternative, nested functions, can be problematically complicated to read. Piping avoids the necessity to assign intermediate objects and makes scripts legible by conducting analyses in sequence.</p>

<p>To illustrate how piping works, let's look again at the nested and non-nested processes that we completed at the start of this section:</p>
```{r pipe reiterate nest, eval = F}
# Non-nested, new object for each step:

z1 <- 1:5

z2 <- multiplyByTwo(1)

addOne(z2)

# Nested:

addOne(multiplyByTwo(1:5))
``` 
<br>
<p>To pipe this operation, we use the pipe symbol, `%>%`,  to separate arguments. The pipe represents the word "then". In piping, the output on the left side of the pipe becomes the first argument in the function on the right. We structure our piped statement similar to that of the non-nested version: "multiply `z` by two <i>then</i> add one to this value". Piping the above, our code would read as:</p> 
```{r pipe version, eval = F}
1:5 %>%
  multiplyByTwo %>%
  addOne
``` 
<br>
<p>Isn't it lovely? Like the nested code, it does not create intermediate obects, and like the non-nested versions of the code it reads from left-to-right (or top-to-bottom).</p>

<p>Notice that I used multiple indented lines of code. For maximal readibility, it is <b>highly recommended</b> that any multi-step operation should be formatted as such (this is considered <b>best management practices</b> for programmers across languages).

<p>You should consider <b>every</b> script you write to be a <b>communication</b> between you and your future self and yourself and fellow scientists. Make sure your scripts communicate clearly -- future you and your fellow scientists will appreciate it greatly!</p>

<hr>
<h2>Joining data</h2>

<p>Recall that one of the rules of tidy data states that "each level of observation forms a table". The table below displays bird banding records at a set of sites.</p> 
```{r messy2NF, echo = FALSE}
kable(messy2NF %>% slice(1:5), "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
<br>
<p>In the above, canopy cover is a condition of site-level observations rather than bird-level observations. Therefore, these sets of values should be divided into two (or more) tables.</p>
<br>
<div class = "row">
<div class = "column">
<p>Bird-level observations</p>
```{r tidy2NFa, echo = FALSE}
kable(tidy2NFobsLevel %>% slice(1:5), "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
<br>
</div>
<div class = "column">
<p>Site-level observations</p>
```{r tidy2NFb, echo = FALSE}
kable(tidy2NFsiteLevel %>% rename(siteId = id), "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
<br>
</div>
</div>
<br>
<p>The above is considerably more tidy but presents a potential problem -- how can we explore variables across tables? To address this, let's look at another example table. The table below provides bird point count and life history data.</p>
```{r messy habits, echo = FALSE}
birdCounts %>%
  left_join(birdHabits, by = 'species') %>%
  select(site, date, species, foraging, diet, count) %>%
  slice(1:10) %>%
  kable("html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
<br>
<p>Note in the table above that count data are bird-level observations while life history traits are species-level observations. To address this, the data need to be separated into individual tables. These tables are provided below (showing just the first 5 records of each table).</p>
```{r tables to join, eval = FALSE}
# Tables to join:

birdCounts

birdHabits
```
<br>

<div class = "row">
<div class = "column">
<p>Bird-level observations (birdCounts)</p>
```{r birdCounts display, echo = FALSE}
kable(birdCounts %>% slice(1:5), "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
<br>
</div>
<div class = "column">
<p>Species-level observations (birdHabits)</p>
```{r birdHabits display, echo = FALSE}
kable(birdHabits %>% slice(1:5), "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
<br>
</div>
</div>

<p>To bring information from the two tables together, we use "join" operations. Below we will explore using a "left-join" but there are several joins available. See `?left_join` for more information.</p>

<p><b>left_join</b>: Join table y to table x using matching value in a column or columns.</p>
<p>
<b>x</b>: The target table</br>
<b>y</b>: The table to be joined to the target</br>
<b>by</b>: A character vector of the columns to join by
</p>
```{r left_join pipe, eval = FALSE}
# Join tables:

left_join(x = birdCounts, y = birdHabits, by = 'species')

# Join birdHabits to birdCounts using a pipe:

birdCounts %>%
  left_join(birdHabits, by = 'species')

```
<br>
<hr>
<h2>Subsetting data</h3>
<br>
<h3>Columns (review)</h3>
<br>
<p>In the previous lesson, we used `select` to subset a data frame by column or index (column number). This is accomplished as below.</p>

<p><b>select</b>: Subset a column of a table by column name or index.</p>
```{r select indexing, eval = FALSE}
birdHabits

# Subset columns using indexing:

birdHabits[, c('species', 'foraging')]

birdHabits[,1:2]

# Subset columns using select:

select(birdHabits, species, foraging)

# Select columns using a pipe:

birdHabits %>%
  select(species, foraging)

```
<br>
<h3>Rows</h3>
<br>
<h4>slice</h4>
<p>Rows can be subset by position (index) using the `slice` function, as below.</p>
```{r slice pipe, eval = FALSE}
birdHabits

# Subset rows using indexing:

birdHabits[1:4,]

# Subset rows using slice:

slice(birdHabits, 1:4)

# Slice rows using a pipe:

birdHabits %>%
  slice(1:4)

```
<br>
<h4>distinct</h4>
<br>
<p>If we were interested in generating a visit table for point counts (the site visited and the date the visit occured), we can use `select` to subset the `birdCounts` frame to just those columns, as below.</p>
```{r distinct 0 , eval = FALSE}
# Subset birdCounts to site and date columns:

select(birdCounts, site, date)
```
<br>
```{r display table distinct 0, echo = FALSE}
kable(select(birdCounts, site, date) %>% slice(1:5), "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
<br>
<p>Doing so, however, breaks one of the <b>rules of tidy data</b> -- "Each observation forms a row". To address this, we can use the function `distinct`, which will remove duplicate records.</p>
```{r distinct pipe, eval = FALSE}
# Subset birdCounts to distinct records of site and date:

distinct(select(birdCounts, site, date))

# Subset to unique site and date records using a pipe:

birdCounts %>%
  select(site, date) %>%
  distinct
```
<br>
<img style="float: right;
	      padding: 9px;
	      padding-right: 0px;
	      border-style: solid;
	      border-width: 10px;
	      box-shadow: 0px 0px 0px 0px;
	      border-color: white;" src="rWorkshop/images/logicalOperators.png" width="40%" />
<h4>filter</h4>
<br>
<p>Throughout this workshop we've done considerable filtering using conditional statements (logic). As you've likely observed, these statements can get very complicated very quickly. The `tidyverse` function `filter` simlifies the process considerably, as diplayed below.</p>
```{r filter pipe, eval = FALSE}
# Subset rows by condition in base R:

birdHabits[birdHabits$diet == 'omnivore',]

# Subset rows by condition using filter:

filter(birdHabits, diet == 'omnivore')

# Filter rows using a pipe:

birdHabits %>%
  filter(diet == 'omnivore')

```
<br>
<p>The `filter` function allows you to apply multiple conditional filters to a data frame in a much more straight-forward fashion:</p>
```{r filter multiple, eval = FALSE}
# Subset rows by multiple conditions in base R:

birdHabits[birdHabits$diet == 'omnivore' &
             birdHabits$foraging == 'ground',]

# Subset rows by multiple conditions using filter:

filter(birdHabits,
       diet == 'omnivore',
       foraging == 'ground')

# Filter rows using a pipe:

birdHabits %>%
  filter(diet == 'omnivore',
         foraging == 'ground')

# or:

birdHabits %>%
  filter(diet == 'omnivore') %>%
  filter(foraging == 'ground')
```

<br>
<blockquote>
<h2><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise One:</h2>
<hr>
<p>Complete the following code to subset `birdCounts` to ground foraging birds!</p>
```{r exercise one, eval = FALSE}
# Subset birdCounts to ground foraging birds:

birdCounts %>%
  left_join(birdHabits # COMPLETE
  filter(foraging # COMPLETE
  select(s # COMPLETE  
         
```
</blockquote>
<br>

<hr>
<h2>Adding & modifying columns</h2>

<h4>transmute</h4>
<p>The function `mutate` can be used to modify an existing column or add a new one.</p>

<p>Modify an existing column:</p>
```{r mutate existing, eval = FALSE}
# Mutate species column in base R:

birdCounts

birdCounts$species <- toupper(birdCounts$species)

birdCount$species <- tolower(birdCount$species)

# Mutate species column using mutate:

mutate(birdCounts, species  = toupper(species))

# Mutate using a pipe:

birdCounts %>%
  mutate(species = toupper(species))
         
```
<br>
<p>Note in the above that the base R version actually overwrote the original species column. This is a big problem that we want to avoid at all costs.</p>

<p>To add a new column using `mutate`, you provide the new column's name:</p>
```{r mutate new pipe, eval = FALSE}
# Add a year column in base R:

birdCounts$year <- year(birdCounts$date)

birdCounts

birdCounts <- birdCounts[,-5]

# Mutate year column using mutate:

mutate(birdCounts, year  = year(date))

# Mutate using a pipe:

birdCounts %>%
  mutate(year = year(date))
         
```
<br>
<p>Again, the base R version added the column to the data frame and is stored in memory. The `mutate` version is considerably safer because nothing is being overwritten.</p>


<h4>transmute</h4>

<p>The function <b>transmute</b> is similar to `mutate` in that it can be used to calculate or modify a new or existing column. If differs in that it will subset the data frame to only the specified columns (similar to select):</p>
```{r transmute pipe, eval = FALSE}
# Add a year column, subset to site and year in base R:

newFrame <- data_frame(
  site = birdCounts$site,
  year = year(birdCounts$date)
)

# Transmute to add a year column, subset to site and year:

transmute(birdCounts,
          site,
          year = year(date))

# Transmute using a pipe:

birdCounts %>%
  transmute(site, year = year(date))

```
<br>
<h3>Renaming columns</h3>
<h4>select and rename</h4>
<p>Finally, we may be interested in maintaining the values of a column but changing its name. To do so, we use the function `select` if we would like to subset the columns along the way or `rename` if we would like to change a name without subsetting the data frame.</p>
```{r select and rename pipe, eval = FALSE}
# Rename the species column using select:

select(birdCounts, site, date, spp = species, count)

# Select using a pipe:

birdCounts %>%
  select(site, date, spp = species, count)

# Rename the species column using rename:

rename(birdCounts, spp = species)

# Rename the species column to spp using rename and a pipe:

birdCounts %>%
  rename(spp = species)

```

<br>
<blockquote>
<h2><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Two:</h2>
<hr>
<p>Filter `birdCounts` to point counts that took place in 2009.</p>
```{r exercise two, eval = FALSE}
# Subset birdCounts to point counts from 2009:

birdCounts %>%
  mutate(year # COMPLETE
  filter(year # COMPLETE
```
<br>
</blockquote>
<br>

<h2>Grouping data</h2>
<hr>
<p>The `tidyverse` function `group_by` allows you to assign groups to a data frame based on a variable in that table. This is equivalent to <b>splitting</b> a data object during a <i>for loop</i> iteration. As an example, let's group `birdCounts` by the `site` variable:</p>
```{r one group pipe, eval = FALSE}
# Group birdCounts by site:

group_by(birdCounts, site)

# Group birdCounts by site using a pipe:

birdCounts %>%
  group_by(site)
```
<br>
<p><i>What did it do</i>? If you look closely at the output you will see that your tibble now contains "Groups: site [30]". This tells you that your tibble has been split into groups. Functions will be applied to each group separately. For example, let's calculate the species richness (`length(unique(species))`) observed at each site by grouping the data frame and using `mutate` to apply the function:</p>
```{r species richness, eval = FALSE}
# Species richness by site (across years):

birdCounts %>%
  group_by(site) %>%
  mutate(nSpecies = length(unique(species))) %>%
  select(site, nSpecies) %>%
  distinct
```
<br>
<p>To conduct the above operation using a <i>for loop</i>, you would use:</p>
```{r species richness site for loop, eval = FALSE}
# Species richness by site (across years), for loop:

sites <- unique(birdCounts$site)

nSpecies <- vector('numeric', length = length(sites))
  
for(i in seq_along(sites)){
  birdCountSubset <- birdCounts[birdCounts$site == sites[i],]
  nSpecies[i] <- length(unique(birdCountSubset$species))
}

data_frame(site = sites, nSpecies)
```
<br>
<p>It is hopefully easy to see that using `tidyverse` functions is a vast improvement over <i>for loops</i>!</p>

<p>`group_by` can be used to split the data frame into multiple groups as well. The following example calculates the species richness for each site and year of observation:</p>
```{r two groups pipe, eval = FALSE}
# Group birdCounts by site and year:

group_by(mutate(birdCounts, year = year(date)), site, year)

# Group birdCounts by site and year using a pipe:

birdCounts %>%
  mutate(year = year(date)) %>%
  group_by(site, year)
```
<br>
<p><i>Note: If you intend to modify your script after using `group_by` be sure to chain the function `ungroup` in a later line. For example, we might want to use `ungroup` within our species richness-by-site calculation:</i></p>
```{r ungroup, eval = FALSE}
# Calculate species richness by site (across years), then ungroup:

birdCounts %>%
  group_by(site) %>%
  mutate(nSpecies = length(unique(species))) %>%
  ungroup %>%
  select(site, nSpecies) %>%
  distinct
```

<br>
<blockquote>
<h2><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Three:</h2>
<hr>
<p>Complete the following to calculate the species richness for each site and year. Ensure that the resulting table is tidy.</p>
```{r exercise three, eval = FALSE}
# Calculate the species richness for each site and year:

birdCounts %>%
  mutate(year = # COMPLETE
  group_by(site, # COMPLETE
  mutate(nSpecies = # COMPLETE
  select(site, year, # COMPLETE
  # COMPLETE
```
<br>
</blockquote>
<br>

<h2>Summarizing data</h2>

<p>The `tidyverse` provides use with the function `summarize` that can be used to calculate a summary function across grouped variables. For example<b>summarize</b>: Calculates a summary function for a grouped variable.</p>
```{r summarize pipe, eval = FALSE}
# Species richness by site, across years:

summarize(group_by(birdCounts, site),
          nSpecies = length(unique(species)))

# Calculate species richness by site using a pipe:

birdCounts %>%
  group_by(site) %>%
  summarize(nSpecies = length(unique(species)))

```
<br>
<blockquote>
<h2><i class= "fa fa-user-circle-o" style = "font-size: 150%;"></i> Exercise Four:</h2>
<hr>
<p>Complete the following to calculate the species richness for each site and year. Ensure that the resulting table is tidy.</p>
```{r exercise four, eval = FALSE}
# Calculate the species richness for each site and year:

birdCounts %>%
  mutate(year # COMPLETE
  group_by(site, # COMPLETE 
  summarize(nSpecies = # COMPLETE
```
<br>
</blockquote>
<br>
<hr>
<h2>Answers to exercises</h2>

<h3><b>Exercise One</b></h3>
<p>Complete the following code to subset `birdCounts` to ground foraging birds!</p>
```{r exercise one answer, eval = FALSE}
# Subset birdCounts to ground foraging birds:

birdCounts %>%
  left_join(birdHabits, by = 'species') %>%
  filter(foraging == 'ground') %>%
  select(site:count)
         
```
<br>
<h3><b>Exercise Two</b></h3>
<p>Filter `birdCounts` to point counts that took place in 2009.</p>
```{r exercise two answer a, eval = FALSE}
# Subset birdCounts to point counts from 2009:

birdCounts %>%
  mutate(year = year(date)) %>%
  filter(year == 2009)
```
<br>
<p>Note: Assigning a new column "year" in this exercise is really not necessary here, because we do not use the year column further. This would have been better written as:</p>
```{r exercise two answer b, eval = FALSE}
# Subset birdCounts to point counts from 2009:

birdCounts %>%
  filter(year(date) == 2009)
```

<br>
<h3><b>Exercise Three</b></h3>
<p>Complete the following to calculate the species richness for each site and year. Ensure that the resulting table is tidy.</p>
```{r exercise three answer, eval = FALSE}
# Calculate the species richness for each site and year:

birdCounts %>%
  mutate(year = year(date)) %>%
  group_by(site, year) %>%
  mutate(nSpecies = length(unique(species))) %>%
  select(site, year, nSpecies) %>%
  distinct
```

<br>
<h3><b>Exercise Four</b></h3>
<p>Complete the following to calculate the species richness for each site and year. Ensure that the resulting table is tidy.</p>
```{r exercise four answer, eval = FALSE}
# Calculate the species richness for each site and year:

birdCounts %>%
  mutate(year = year(date)) %>%
  group_by(site, year) %>% 
  summarize(nSpecies = length(unique(species)))
```
<br>